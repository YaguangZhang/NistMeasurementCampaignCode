%EVALPERFBASEDONSIMRESULTS Evaluation the performance of site-specific
%models according to the simulation results from Lab
%
% Yaguang Zhang, Purdue, 09/13/2019

clearvars -except getUsgsEleInMFromUtmXY; clc; close all;

%% Configurations

warning('on');

% Add libs to current path and set ABS_PATH_TO_NIST_SHARED_FOLDER according
% to the machine name.
cd(fileparts(mfilename('fullpath')));
addpath(fullfile(pwd));
cd('..'); setPath;

% We will need computeFreeSpacePathLosses.m.
addpath(fullfile(pwd, '4_FoliageAttenuationEstimation'));

% We will need the functions latLon2PixIndices.m and pixIndices2LatLon.m
% for working with the vegArea image.
addpath(fullfile(pwd, '9_GenerateVegAreas'));

% We will need the functions countNumOfFoliagePixelsInFirstFresnelZone.m
addpath(fullfile(pwd, '10_CompareFoliageDepthBasedModels'));

% Path to the simulation result xlsx files.
ABS_DIR_TO_SIM_RESULTS = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'Data', '20191011_NistFoliageSimulationResults');

% Path to the simulation result xlsx files.
ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'Data', '20191016_NistFoliageSimulationResultsForGrid', ...
    'var_grnd_grid_propagation_stats_20191029.xlsx');

% Configure other paths accordingly.
ABS_PATH_TO_SAVE_PLOTS = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PerformanceEvaluationBasedOnSimulations');

% Reuse results from evalPathLossesForContiTracks.m and
% loadMeasCampaignInfo.m.
ABS_PATH_TO_PATH_LOSSES_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputationConti', ...
    'contiPathLossesWithGpsInfo.mat');
ABS_PATH_TO_TX_INFO_LOGS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputation', 'txInfoLogs.mat');

% Reuse results from generateVegAreas.m.
ABS_PATH_TO_VEG_AREAS_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'AutoGeneratedVegAreas', 'vegAreasMeta.mat');

% Reuse results from estimateFoliageAttenuation.m.
ABS_PATH_TO_UTM_INFO_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'FoliageAttenuationEstimation', ...
    'utmInfoForPathLossesAndTrees.mat');

% Reuse results from estimateFoliageAttenuationWithManualTreeLocs.m.
ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageAttenuationEstimation_ManualTreeLocs', ...
    'foliageAttenAnalysisResults.mat');

% Reuse results from compareFoliageDepthBasedModels.m.
ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageDepthBasedModelsComparison', ...
    'foliageDepthBasedAttenAnalysisResults.mat');

% Reuse results from inspectOutlayers.m.
ABS_PATH_TO_BEAM_POLYGONS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    '13_OutlayerInspection', ...
    'beamPolygons.mat');

% Reuse .csv files exported for simulation.
ABS_PATH_TO_SIM_CSV_FILES ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'SimulationDataExportationExtended');

% The lengths of path within woodland (for the ITU model) and site-specific
% foilage areas will be saved into a file.
pathToSavePredictionsForGrid ...
    = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'predictionsForExtendedGrid.mat');

% The predictions from selected models will be saved.
pathToSaveGrid ...
    = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simulationGrid.mat');

% The 3 segment for length of path within woodland for evaluating the
% performance (root-mean-square deviation) for the ITU model. Each segment
% will be the min and max values in the form of [min, max), i.e. including
% min but excluding max.
segmentsForRmsdDw = {[0,30], [30,220], [220, inf]};

% The 3 segment for the foliage depth for evaluating the performance of
% Weissberger's model. Each segment will be the min and max values in the
% form of [min, max), i.e. including min but excluding max.
segmentsForRmsdDf = {[0,15], [15,75], [75, inf]};

% The updated tree locations.
ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'ManuallyLocateMoreTrees', 'treeLocs.mat');

% For creating a grid to cover a larger area than that covered by our
% measurements. We will need the (latitude, longitude) range polygon stored
% as a polyshape to determin which area to cover.
latLonEdgesDeterminedByTerrain = {[39.992772, -105.275100; ...
    39.990018, -105.278469]; ...
    [39.989118, -105.276475; ...
    39.991211, -105.272842]};

% Control the truncation of the data in the output .csv files.
dataStrFormatter = '%.12f';

% For plotting.
lightGray = ones(1,3).*0.7;

% We will use this number of pixels for the longer side (width/height) of
% the simulation area; the number of pixels for the other side will be
% proportional to its length.
simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE = 100;

% For plotting.
areaOfInterestColor = [0.9290 0.6940 0.1250];
lightBlue = [0.3010 0.7450 0.9330];
darkBlue = [0 0.4470 0.7410];

% Set this to true to avoid showing the figures while they are being
% generated.
flagGenFigSilently = true;

% The measurement area.
figAxisToSet = [-105.2774429259207, -105.2744429246357, ...
    39.9893839683981, 39.9915745444857];

% Calibrate the simulation results for the grid according to close-in
% 'FSPL', 'cleanedMeas', or 'trackOneOnGrid':
%   - FSPL
%     We will find a close-in reference point and shift the simulation
%     results for the grid as a whole so that at the reference point the
%     simulation result will agree with FSPL.
%   - cleanedMeas
%     We will find a shift for the whole grid simulation results according
%     to the best shift and multiplication factor from the simulation
%     results for the cleaned data set.
%   - trackOneOnGrid
%     We will find the nearest neighbor grid point for each measurement
%     location on track 1 and calibrate the grid simulation results
%     according to those on the fetched locations (compared to the cleaned
%     measurement data).
%   - cleanedMeasOnGrid
%     Similar to 'trackOneOnGrid', but instead of using only track 1, we
%     will use all the cleaned measurement data.
simGridLossCalibMethod = 'cleanedMeas';

%% Before Processing the Data

curFileName = mfilename;
fileNameHintRuler = [' ', repmat('-', 1, length(curFileName)+2), ' '];
disp(fileNameHintRuler)
disp(['  ', curFileName, '  '])
disp(fileNameHintRuler)

% Create directories if necessary.
if exist(ABS_PATH_TO_SAVE_PLOTS, 'dir')~=7
    mkdir(ABS_PATH_TO_SAVE_PLOTS);
end

%% Get Info for Measurement Data Files and Calibration Polynomials

disp(' ')
disp('    Loading results from: ')
disp('      - contiPathLossesWithGpsInfo.mat')
disp('      - txInfoLogs.mat')
disp('      - vegAreasMeta.mat')
disp('      - utmInfoForPathLossesAndTrees.mat')
disp('      - treeLocs.mat (Extended)')

assert(exist(ABS_PATH_TO_PATH_LOSSES_FILE, 'file')==2, ...
    'Couldn''t find contiPathLossesWithGpsInfo.mat! Please run 3_PathLossComputation/evalPathLossesForContiTracks.m first.');
assert(exist(ABS_PATH_TO_TX_INFO_LOGS_FILE, 'file')==2, ...
    'Couldn''t find txInfoLogs.mat! Please run 3_PathLossComputation/loadMeasCampaignInfo.m first.');
assert(exist(ABS_PATH_TO_VEG_AREAS_FILE, 'file')==2, ...
    'Couldn''t find vegAreasMeta.mat! Please run 9_GenerateVegAreas/generateVegAreas.m first.');
assert(exist(ABS_PATH_TO_UTM_INFO_FILE, 'file')==2, ...
    'Couldn''t find utmInfoForPathLossesAndTrees.mat! Please run 4_FoliageAttenuationEstimation/estimateFoliageAttenuation.m first.');
assert(exist(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE, 'file')==2, ...
    'Couldn''t find foliageAttenAnalysisResults.mat! Please run 8_FoliageAttenuationEstimation_ManualTreeLocs/estimateFoliageAttenuationWithManualTreeLocs.m first.');
assert(exist(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, 'file')==2, ...
    'Couldn''t find foliageDepthBasedAttenAnalysisResults.mat! Please run 10_CompareFoliageDepthBasedModels/compareFoliageDepthBasedModels.m first.');
assert(exist(ABS_PATH_TO_BEAM_POLYGONS_FILE, 'file')==2, ...
    'Couldn''t find beamPolygons.mat! Please run 13_OutlayerInspection/inspectOutlayers.m first.');
assert(exist(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS, 'file')==2, ...
    'Couldn''t find treeLocs.mat! Please run NistMeasurementCampaignCode/15_PerfEvaluationBasedOnSim/manuallyLocateMoreTrees.m first.');


% The data have been processed before and the result files have been found.
disp('    Found all .mat files required.');
disp('        Loading the results...');

% Get 'contiPathLossesWithGpsInfo', 'contiOutFilesRelPathsUnderDataFolder'
% and 'contiOutFileIndicesReflection'.
load(ABS_PATH_TO_PATH_LOSSES_FILE);
% Get records of the TxInfo.txt files (among other contant parameters for
% the measurement campaign, e.g. F_S, TX_LAT, TX_LON, and TX_POWER_DBM):
% 	'TX_INFO_LOGS' and 'TX_INFO_LOGS_ABS_PAR_DIRS'.
load(ABS_PATH_TO_TX_INFO_LOGS_FILE);
% Get 'vegAreas', 'LAT_RANGE', 'LON_RANGE', 'VEG_AREA_IMG_RESOLUTION', and
% 'VEG_AREA_IMG_META'.
load(ABS_PATH_TO_VEG_AREAS_FILE);
% Get 'xTx', 'yTx', 'txUtmZone', 'treeLocations', 'pathLossUtmXYHs',
% 'pathLossUtmZones', 'treeUtmXYHs', and 'treeUtmZones'.
load(ABS_PATH_TO_UTM_INFO_FILE);
% Get 'numsOfTreesInFirstFresnel', 'freeSpacePathLosses',
% 'exceLossRefFreeSpace', 'excePathLossPerTree',
% 'shiftedFreeSpacePathLosses', 'excePathLossGroupWise', and
% 'groupWiseShiftedFreeSpacePathLosses'.
load(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE);
% Get 'modelTwoStepLinearLossWrtWFA' and all other site-specific models.
load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE);
% Get 'modelTwoStepLinearLossWrtWFA' and all other site-specific models.
load(ABS_PATH_TO_BEAM_POLYGONS_FILE);
% Get 'markLocs'.
load(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS);

disp('    Done!');

%% Create the Grid

disp(' ');
disp('    Generating extended RX location grid...');

% Create the grid in (lon, lat).
lonsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,2)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,2)'];
latsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,1)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,1)'];

lonVegArealimit = VEG_AREA_IMG_META.LON_RANGE;
latVegArealimit = VEG_AREA_IMG_META.LAT_RANGE;
lonsVegAreaPolygon = lonVegArealimit([1 1 2 2 1]);
latsVegAreaPolygon = latVegArealimit([1 2 2 1 1]);

[lonsEdgeIntersection, latsEdgeIntersection] = polyxpoly( ...
    lonsVegAreaPolygon, latsVegAreaPolygon, ...
    lonsEdgesDeterminedByTerrain, latsEdgesDeterminedByTerrain);

latLonRangePolyVertices = convexHull( ...
    [lonsEdgeIntersection latsEdgeIntersection; ...
    lonVegArealimit' latVegArealimit']);

if exist(pathToSaveGrid, 'file')
    histSimGridResults ...
        = load(pathToSaveGrid, 'simGrid');
else
    histSimGridResults.simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE = nan;
end

if histSimGridResults.simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE ...
        == simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE
    simGrid = histSimGridResults.simGrid;
else
    simGrid.latLonRangePolyshape = polyshape(latLonRangePolyVertices);
    
    % Convert to UTM (x, y).
    [xRangePolyVertices, yRangePolyVertices, utmZonesPoly] = deg2utm( ...
        latLonRangePolyVertices(:,2), latLonRangePolyVertices(:,1));
    simGrid.xYRangePolyshape = polyshape( ...
        [xRangePolyVertices yRangePolyVertices]);
    
    simGrid.utmZone = utmZonesPoly(1,:);
    
    % Construct the grid accordingly.
    simAreaMinX = min(simGrid.xYRangePolyshape.Vertices(:,1));
    simAreaMaxX = max(simGrid.xYRangePolyshape.Vertices(:,1));
    simAreaMinY = min(simGrid.xYRangePolyshape.Vertices(:,2));
    simAreaMaxY = max(simGrid.xYRangePolyshape.Vertices(:,2));
    
    simAreaWidthInM = simAreaMaxX-simAreaMinX;
    simAreaHeightInM = simAreaMaxY-simAreaMinY;
    
    gridResolution = max([simAreaWidthInM, simAreaHeightInM]) ...
        ./simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE;
    simGrid.resolutionInM = gridResolution;
    
    simAreaXLabels = constructAxisGrid( ...
        mean([simAreaMaxX, simAreaMinX]), ...
        floor((simAreaMaxX-simAreaMinX)./gridResolution), gridResolution);
    simAreaYLabels = constructAxisGrid( ...
        mean([simAreaMaxY, simAreaMinY]), ...
        floor((simAreaMaxY-simAreaMinY)./gridResolution), gridResolution);
    [simAreaXs, simAreaYs] = meshgrid(simAreaXLabels,simAreaYLabels);
    
    % Discard map grid points out of the area of interest.
    boolsGridPtsToKeep = inpolygon(simAreaXs(:), simAreaYs(:), ...
        simGrid.xYRangePolyshape.Vertices(:,1), ...
        simGrid.xYRangePolyshape.Vertices(:,2));
    
    simGrid.utmXYs = [simAreaXs(boolsGridPtsToKeep), ...
        simAreaYs(boolsGridPtsToKeep)];
    
    simGridXs = simGrid.utmXYs(:,1);
    simGridYs = simGrid.utmXYs(:,2);
    
    simGridNumOfPts = length(simGridXs);
    simGridZones = repmat(simGrid.utmZone, simGridNumOfPts, 1);
    [simGridLats, simGridLons] ...
        = utm2deg(simGridXs, simGridYs, simGridZones);
    simGrid.latLons = [simGridLats, simGridLons];
    
    % Use USGS 1/3 arc-second (~10m) resolution data for US terrain
    % elevation.
    latRange = [min(simGridLats), max(simGridLats)];
    lonRange = [min(simGridLons), max(simGridLons)];
    region = fetchregion(latRange, lonRange, 'display', true);
    nistElevData = region.readelevation(latRange, lonRange, ...
        'sampleFactor', 1, 'display', true);
    % Interperlate nistElevData to get lidarAlts.
    [nistElevDataLons, nistElevDataLats] = meshgrid( ...
        nistElevData.longs, nistElevData.lats);
    simGrid.eles = interp2( ...
        nistElevDataLons, nistElevDataLats, ...
        nistElevData.elev, ...
        simGridLons, simGridLats);
    
    % Fill USGS elevations in the spots with NaN elevation values.
    boolsNanEle = isnan(simGrid.eles);
    if any(boolsNanEle)
        simGrid.eles(boolsNanEle) = queryElevationPointsFromUsgs( ...
            simGridLats(boolsNanEle), simGridLons(boolsNanEle), 'matlab');
    end
    assert(all(~isnan(simGrid.eles)), ...
        'There are NaN elevation values for the grid points!');
    save(pathToSaveGrid, 'simGrid');
end

% Plot.
hFigAreaOfInterest = figure('visible', ~flagGenFigSilently); hold on;
hAreaOfInterest = plot( ...
    simGrid.xYRangePolyshape, ...
    'FaceColor', areaOfInterestColor);
hGridPts = plot(simGrid.utmXYs(:,1), ...
    simGrid.utmXYs(:,2), '.b', 'MarkerSize', 3, 'Color', darkBlue);
axis equal; view(2); grid on;
legend([hAreaOfInterest, hGridPts], ...
    'Area of interest', 'RX location grid points', ...
    'Location', 'SouthEast');
transparentizeCurLegends;


curDirToSave = fullfile(ABS_PATH_TO_SAVE_PLOTS, 'Overview_RxLocGrid.png');
saveas(hFigAreaOfInterest, curDirToSave);

disp('    Done!')

%% Export Grid as a Simulation RX Track

disp(' ');
disp('    Exporting grid to .csv...');

gridTrackFileLabel = 'simGrid';

% For convenience.
if ~exist('simGridXs', 'var')
    simGridXs = simGrid.utmXYs(:,1);
    simGridYs = simGrid.utmXYs(:,2);
    simGridLats = simGrid.latLons(:,1);
    simGridLons = simGrid.latLons(:,2);
    simGridNumOfPts = length(simGridXs);
    simGridZones = repmat(simGrid.utmZone, simGridNumOfPts, 1);
end

% Function to fetch elevation according to the vegetation data structure.
if ~exist('getUsgsEleInMFromUtmXY', 'var')
    disp('        Generating getUsgsEleInMFromUtmXY...');
    getUsgsEleInMFromUtmXY = scatteredInterpolant( ...
        VEG_AREA_IMG_META.XS(:), ...
        VEG_AREA_IMG_META.YS(:), ...
        VEG_AREA_IMG_META.ALTS(:));
end
TX_ALT_USGS = getUsgsEleInMFromUtmXY(xTx, yTx);

% RX grid points.
fullPathRxLocs = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_track_', gridTrackFileLabel, '.csv']);

curAltsUsgsRx = getUsgsEleInMFromUtmXY(simGridXs, simGridYs);
% Fill USGS elevations in the spots with NaN elevation values.
boolsNanEle = isnan(curAltsUsgsRx);
if any(boolsNanEle)
    curAltsUsgsRx(boolsNanEle) = queryElevationPointsFromUsgs( ...
        simGridLats(boolsNanEle), simGridLons(boolsNanEle), 'matlab');
end
assert(all(~isnan(curAltsUsgsRx)), ...
    'There are NaN USGS elevation values for the grid points!');

curRxGroundHeightWrtTx ...
    = curAltsUsgsRx-(TX_ALT_USGS+TX_HEIGHT_M);

if exist(fullPathRxLocs, 'file')
    disp('        Skipping track csv file generation for the grid!');
else
    curHeaderCell = {'utmX', 'utmY', 'utmZone', ...
        'lat', 'lon', 'altFromUsgs', 'rxHeightWrtTXInM'};
    
    curRxHeightWrtTxInM = (RX_HEIGHT_M+curAltsUsgsRx)...
        -(TX_ALT_USGS+TX_HEIGHT_M);
    
    curData = [num2cell([simGridXs, ...
        simGridYs]), ...
        cellstr(simGridZones), ...
        ...
        num2cell([simGridLats, simGridLons, ...
        curAltsUsgsRx, ...
        curRxHeightWrtTxInM])];
    writeToCsvWithHeader(fullPathRxLocs, curHeaderCell, ...
        curData, dataStrFormatter);
end

% Measurement results. For fields that we do no have data, we need to pad
% NaNs.
fullPathRxMeas = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_meas_', gridTrackFileLabel, '.csv']);
if exist(fullPathRxMeas, 'file')
    disp('        Skipping meas csv file generation for the grid!');
else
    curHeaderCell = {'locIdx', 'pathLossInDb', 'rxToTx3DDistInM', ...
        'txAzimuth (clockwise from positive y)', ...
        'txElevation ("+" for upward)', ...
        'rxAzimuth (clockwise from positive y)', ...
        'rxElevation ("+" for upward)'};
    
    curRxToTx3DDistInM = vecnorm([simGridXs - xTx, ...
        simGridYs - yTx, curRxHeightWrtTxInM], 2, 2);
    
    nanPaddings = nan(simGridNumOfPts, 1);
    onesWithNumOfCurMeas = ones(simGridNumOfPts, 1);
    
    curData = [(1:simGridNumOfPts)', nanPaddings, curRxToTx3DDistInM, ...
        nanPaddings, ...
        nanPaddings, ...
        nanPaddings, ...
        nanPaddings];
    writeToCsvWithHeader(fullPathRxMeas, curHeaderCell, ...
        curData, dataStrFormatter);
end

disp('    Done!');

%% Figures According to the Exported .csv Files

disp(' ');
disp('    Generate figures according to exported .csv files...');

% rxLoc_track_#.csv
rxLocExp = readtable(fullPathRxLocs);
rxUtmXYsExp = [rxLocExp.utmX, rxLocExp.utmY];
rxLonLatExp = [rxLocExp.lon, rxLocExp.lat];
rxHeightWrtTxExp = rxLocExp.rxHeightWrtTXInM;

% TX GPS location.
[latTx, lonTx] = utm2deg(xTx, yTx, txUtmZone);

% Overview figure on a map.
curFigTitle = {'Simulation Grid Overview'; ...
    'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewLonLatHByCsv.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;
hTx = plot(lonTx, latTx, 'gx');
hRx = plot(rxLonLatExp(:,1), rxLonLatExp(:,2), ...
    'r.', 'MarkerSize', 5);
hLidar = plot(lonsVegAreaPolygon, latsVegAreaPolygon, ...
    '-w', 'LineWidth', 3);
plot_google_map('MapType', 'satellite');
xlabel('Longtitude'); ylabel('Latitude');
legend([hTx, hRx, hLidar], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');
transparentizeCurLegends;

title(curFigTitle)
saveas(curFig, curFigPath);

% LiDAR data.
downSampleRate = 30;
fctDownSample = @(x) x(1:downSampleRate:end, 1:downSampleRate:end);
vegXsLessExp = fctDownSample(VEG_AREA_IMG_META.XS);
vegYsLessExp = fctDownSample(VEG_AREA_IMG_META.YS);
vegZsWrtTxLessExp = fctDownSample( ...
    VEG_AREA_IMG_META.ZS-TX_ALT_USGS-TX_HEIGHT_M);

[xsVegAreaPolygon, ysVegAreaPolygon] ...
    = deg2utm(latsVegAreaPolygon, lonsVegAreaPolygon);

% Overview figure in UTM.
curFigTitle = {'Simulation Grid Overview in 3D'; ...
    'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewUtmXYHByCsv.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;

hLidar = plot3k([vegXsLessExp(:), vegYsLessExp(:), ...
    vegZsWrtTxLessExp(:)], 'Marker', {'.', 3}, 'ColorBar', false);

plot3([xTx xTx],[yTx yTx],[-TX_HEIGHT_M 0], 'g-');
hTx = plot3(xTx, yTx, 0, 'gx', 'LineWidth', 3, 'MarkerSize', 8);

plot3([rxUtmXYsExp(:,1) ...
    rxUtmXYsExp(:,1)]', ...
    [rxUtmXYsExp(:,2) ...
    rxUtmXYsExp(:,2)]', ...
    [rxHeightWrtTxExp curRxGroundHeightWrtTx]', ...
    'r-');
hRx = plot3(rxUtmXYsExp(:,1), rxUtmXYsExp(:,2), rxHeightWrtTxExp, ...
    'r.', 'MarkerSize', 5);

hLidarArea = plot(xsVegAreaPolygon, ysVegAreaPolygon, ...
    '-k', 'LineWidth', 3);

grid on; axis tight; axis equal; view(3);
xlabel('utmX'); ylabel('utmY'); ylabel('Height');
legend([hTx, hRx, hLidarArea], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');

title(curFigTitle)
saveas(curFig, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Generate Figures for Orignal Measurements
FLAG_GEN_FIGS_SILENTLY = flagGenFigSilently;

numOfTracks = length(contiPathLossesWithGpsInfo);
boolsToKeepMeas = cell(numOfTracks,1);
for idxTrack = 1:numOfTracks
    curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
    boolsToKeepMeas{idxTrack} = true(length(curLats),1);
end

curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simVsMeas'); %#ok<*NASGU>
genEvalPerfFigsForMeas;

%% Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary.

numOfTracks = length(contiPathLossesWithGpsInfo);
boolsToKeepMeas = cell(numOfTracks,1);
for idxTrack = 1:numOfTracks
    curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
    curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
    boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
        fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
        fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
end

curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, 'simVsMeasLess');
genEvalPerfFigsForMeas;

%% Further Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary. Furthermore, we will discard track 6.

numOfTracks = length(contiPathLossesWithGpsInfo);
boolsToKeepMeas = cell(numOfTracks,1);
for idxTrack = 1:numOfTracks
    curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
    curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
    if idxTrack == 6
        boolsToKeepMeas{idxTrack} = false(length(curLons), 1);
    else
        boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
            fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
            fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
    end
end

curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simVsMeasLessNoTrackSix');
genEvalPerfFigsForMeas;

allBoolsToKeepMeas = vertcat(boolsToKeepMeas{:});

%% Further Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary. Furthermore, we will discard track 6 and track 10.
if false
    numOfTracks = length(contiPathLossesWithGpsInfo);
    boolsToKeepMeas = cell(numOfTracks,1);
    for idxTrack = 1:numOfTracks
        curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
        curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
        if (idxTrack == 6) || (idxTrack == 10)
            boolsToKeepMeas{idxTrack} = false(length(curLons), 1);
        else
            boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
                fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
                fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
        end
    end
    
    curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
        'simVsMeasLessNoTrackSixNorTen');
    genEvalPerfFigsForMeas;
    
    allBoolsToKeepMeas = vertcat(boolsToKeepMeas{:});
end
%% Prepare Results for Cleaned Measurements

tx3D = [xTx, yTx, ...
    queryElevationPointsFromUsgs(latTx, lonTx, 'matlab')+TX_HEIGHT_M];
srcGpsPt3D = [latTx, lonTx, tx3D(3)];

% Evaluate the foliage area and distance in woodland for all the measured
% locations.
if exist(pathToSavePredictionsForGrid, 'file')
    disp('    Loading history results...');
    load(pathToSavePredictionsForGrid);
else
    allContiPathLossesWithGpsInfo = vertcat(contiPathLossesWithGpsInfo{:});
    [numOfMeasPts, ~] = size(allContiPathLossesWithGpsInfo);
    allMeasNumsOfFoliagePixelsInFirstFresnel = deal(nan(numOfMeasPts, 1));
    allMeasUtmXYs = nan(numOfMeasPts, 2);
    
    disp(' ');
    disp('            Foliage area computation for all measurements...');
    
    allMeasLats = allContiPathLossesWithGpsInfo(:, 2);
    allMeasLons = allContiPathLossesWithGpsInfo(:, 3);
    [allMeasXs, allMeasYs, ~] = deg2utm(allMeasLats, allMeasLons);
    allMeasUtmXYs = [allMeasXs, allMeasYs];
    
    allMeasEles = getUsgsEleInMFromUtmXY(allMeasXs, allMeasYs);
    assert(all(~isnan(allMeasEles)), ...
        'NaN elevation value(s) found in measurement dataset!');
    
    ratioToReportProgress = 0.05;
    numOfMeasToReportProgress = ceil(numOfMeasPts.*ratioToReportProgress);
    parfor idxMeasPt = 1:numOfMeasPts
        curMeasLat = allMeasLats(idxMeasPt);
        curMeasLon = allMeasLons(idxMeasPt);
        curMeasEle = allMeasEles(idxMeasPt);
        
        dstGpsPt3D = [curMeasLat, curMeasLon, curMeasEle+RX_HEIGHT_M];
        
        [allMeasNumsOfFoliagePixelsInFirstFresnel(idxMeasPt), ~, ~]...
            = countNumOfFoliagePixelsInFirstFresnelZone(...
            srcGpsPt3D, dstGpsPt3D, ...
            vegAreas, VEG_AREA_IMG_META, F_C_IN_GHZ);
        if mod(idxMeasPt, numOfMeasToReportProgress)==1
            disp(['                Progress: ', ...
                num2str(idxMeasPt./numOfMeasPts.*100, '%.2f'), ...
                '% (pt #', num2str(idxMeasPt), ...
                '/', num2str(numOfMeasPts), ')']);
        end
    end
    
    measPredResults.allContiPathLossesWithGpsInfo ...
        = allContiPathLossesWithGpsInfo;
    measPredResults.utmXYs = allMeasUtmXYs;
    measPredResults.eles = allMeasEles;
    measPredResults.foliageAreasInFirstFresnel ...
        = allMeasNumsOfFoliagePixelsInFirstFresnel ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(1) ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(2);
    
    % FSPL for the measured locations.
    disp(' ');
    disp('            FSPL computation for the measurements...');
    [measPredResults.fsplInDb, ...
        measPredResults.distsToTxInM3d] ...
        = computeFreeSpacePathLosses(tx3D, ...
        [measPredResults.utmXYs, ...
        measPredResults.eles+RX_HEIGHT_M], F_C_IN_GHZ);
    disp('                Done!');
    
    disp(' ');
    disp('            Saving results for the cleaned measurements...');
    cleanedMeasPredResults.allContiPathLossesWithGpsInfo ...
        = measPredResults ...
        .allContiPathLossesWithGpsInfo(allBoolsToKeepMeas, :);
    cleanedMeasPredResults.utmXYs ...
        = measPredResults.utmXYs(allBoolsToKeepMeas, :);
    cleanedMeasPredResults.eles ...
        = measPredResults.eles(allBoolsToKeepMeas);
    cleanedMeasPredResults.foliageAreasInFirstFresnel ...
        = measPredResults.foliageAreasInFirstFresnel(allBoolsToKeepMeas);
    cleanedMeasPredResults.fsplInDb ...
        = measPredResults.fsplInDb(allBoolsToKeepMeas);
    cleanedMeasPredResults.distsToTxInM3d ...
        = measPredResults.distsToTxInM3d(allBoolsToKeepMeas);
    
    disp('                Done!');
end

%% Predictions for Extended RX Location Grid
% We will consider site-specific model C and the ITU model.

disp(' ');

if exist(pathToSavePredictionsForGrid, 'file')
    disp('    Loading history results...');
    load(pathToSavePredictionsForGrid);
else
    disp('    Generating predictions for extended RX locations...');
    
    disp('        FSPL...');
    % Free space loss values for all the points in the extended RX location
    % grid.
    [simGridPredResults.fsplInDb, simGridPredResults.distsToTxInM3d] ...
        = computeFreeSpacePathLosses(tx3D, ...
        [simGrid.utmXYs, simGrid.eles+RX_HEIGHT_M], F_C_IN_GHZ);
    
    disp('        Site-specific model C...');
    % Site-specific model C.
    historyModelResult ...
        = load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, ...
        'modelTwoStepLinearLossWrtFA');
    simGridPredResults.modelTwoStepLinearLossWrtFA ...
        = historyModelResult.modelTwoStepLinearLossWrtFA;
    
    % Estimate foliage areas, considering the RX height over the ground.
    numOfGridPts = length(simGrid.eles);
    simGridNumsOfFoliagePixelsInFirstFresnel = nan(numOfGridPts, 1);
    disp('            Foliage area computation...');
    
    ratioToReportProgress = 0.05;
    numOfMeasToReportProgress = ceil(numOfMeasPts.*ratioToReportProgress);
    parfor idxGridPt = 1:numOfGridPts
        dstGpsPt3D = [simGrid.latLons(idxGridPt,:), ...
            simGrid.eles(idxGridPt)+RX_HEIGHT_M]; %#ok<PFBNS>
        [simGridNumsOfFoliagePixelsInFirstFresnel(idxGridPt), ~, ~]...
            = countNumOfFoliagePixelsInFirstFresnelZone(...
            srcGpsPt3D, dstGpsPt3D, ...
            vegAreas, VEG_AREA_IMG_META, F_C_IN_GHZ);
        if mod(idxGridPt, numOfMeasToReportProgress)==1
            disp(['                Progress: ', ...
                num2str(idxGridPt./numOfGridPts.*100, '%.2f'), ...
                '% (pt #', num2str(idxGridPt), ...
                '/', num2str(numOfGridPts), ')']);
        end
    end
    
    disp('                Done!');
    simGridPredResults.foliageAreasInFirstFresnel ...
        = simGridNumsOfFoliagePixelsInFirstFresnel ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(1) ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(2);
    
    simGridPredResults.siteSpecificModelCPredictionsInDbOld ...
        = simGridPredResults.fsplInDb ...
        + simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        simGridPredResults.foliageAreasInFirstFresnel, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    measPredResults.siteSpecificModelCPredictionsInDbOld ...
        = measPredResults.fsplInDb ...
        + simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        measPredResults.foliageAreasInFirstFresnel, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbOld ...
        = cleanedMeasPredResults.fsplInDb ...
        + simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    disp('        ITU...');
    % ITU.
    historyModelResult = load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, ...
        'modelItuObsByWoodland');
    simGridPredResults.modelItuObsByWoodland ...
        = historyModelResult.modelItuObsByWoodland;
    
    % The clearance zone needed for the ITU model to compute the
    % in-woodland distance.
    firstVertex = [39.9914866126997, -105.274771171001];
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        = [ firstVertex; ...
        ...
        39.9913983555729, -105.274683363792; ...
        39.99124280167, -105.27456460806; ...
        39.9912124631283, -105.274460246949; ...
        39.9911694375684, -105.274395471159; ...
        39.9910425673101, -105.274183150317; ...
        39.9918227291569, -105.274511732652; ...
        39.9917942146102, -105.274643656646; ...
        39.9916127585283, -105.274649294408; ...
        39.9918832145105, -105.274199963594; ...
        39.9919402435825, -105.274356693825; ...
        39.9917047826908, -105.27391130951; ...
        39.9918097680052, -105.273976707698; ...
        39.9916887972767, -105.273839709727; ...
        39.9916093022227, -105.273700456614; ...
        39.9913785927558, -105.273739921031; ...
        39.9912403393027, -105.27389721502; ...
        39.99131983505, -105.274652677151; ...
        39.9917316722478, -105.273962967618; ...
        ...
        firstVertex];
    [clearanceZoneBoundXs, clearanceZoneBoundYs] = deg2utm( ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2));
    [~, ~, clearanceZoneBoundNewOrderIndices] ...
        = orderPolygonVertices( ...
        clearanceZoneBoundXs, clearanceZoneBoundYs);
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        = simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        (clearanceZoneBoundNewOrderIndices, :);
    clearanceZoneBoundXs = clearanceZoneBoundXs ...
        (clearanceZoneBoundNewOrderIndices, :);
    clearanceZoneBoundYs = clearanceZoneBoundYs ...
        (clearanceZoneBoundNewOrderIndices, :);
    
    % Compute distance in woodland for the grid.
    disp(' ');
    disp('            Woodland distances for the grid...');
    numOfGridPts = length(simGrid.eles);
    estiDistsNotInWoodland = nan(numOfGridPts, 1);
    for idxGridPt = 1:numOfGridPts
        curGridPtX = simGrid.utmXYs(idxGridPt, 1);
        curGridPtY = simGrid.utmXYs(idxGridPt, 2);
        curLineTxToRxXs = [curGridPtX, xTx];
        curLineTxToRxYs = [curGridPtY, yTx];
        [interXs, interYs] = polyxpoly( ...
            curLineTxToRxXs, curLineTxToRxYs, ...
            clearanceZoneBoundXs, clearanceZoneBoundYs);
        estiDistsNotInWoodland(idxGridPt) ...
            = norm([interXs-xTx, interYs-yTx]);
    end
    simGridPredResults.estiDistsInWoodland ...
        = simGridPredResults.distsToTxInM3d-estiDistsNotInWoodland;
    boolsGridPtsOutofWood = inpolygon(simGridLons, simGridLats, ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
    simGridPredResults.estiDistsInWoodland(boolsGridPtsOutofWood) = 0;
    disp('                Done!');
    
    simGridPredResults.ituPredictionsInDbOld = ...
        simGridPredResults.fsplInDb ...
        + simGridPredResults.modelItuObsByWoodland.excessLossFormula( ...
        simGridPredResults.estiDistsInWoodland, ...
        simGridPredResults.modelItuObsByWoodland.gammaRecommended, ...
        simGridPredResults.modelItuObsByWoodland.AmFitted);
    
    % Compute distance in woodland for measurements.
    disp(' ');
    disp('            Woodland distances for the measurements...');
    numOfMeasPts = length(allBoolsToKeepMeas);
    estiDistsNotInWoodland = nan(numOfMeasPts, 1);
    for idxMeasPt = 1:numOfMeasPts
        curGridPtX = measPredResults.utmXYs(idxMeasPt, 1);
        curGridPtY = measPredResults.utmXYs(idxMeasPt, 2);
        curLineTxToRxXs = [curGridPtX, xTx];
        curLineTxToRxYs = [curGridPtY, yTx];
        [interXs, interYs] = polyxpoly( ...
            curLineTxToRxXs, curLineTxToRxYs, ...
            clearanceZoneBoundXs, clearanceZoneBoundYs);
        estiDistsNotInWoodland(idxMeasPt) ...
            = norm([interXs-xTx, interYs-yTx]);
    end
    measPredResults.estiDistsInWoodland ...
        = measPredResults.distsToTxInM3d-estiDistsNotInWoodland;
    allContiPathLossesWithGpsInfo = vertcat(contiPathLossesWithGpsInfo{:});
    boolsMeasPtsOutOfWood = inpolygon( ...
        allContiPathLossesWithGpsInfo(:, 3), ...
        allContiPathLossesWithGpsInfo(:, 2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
    measPredResults.estiDistsInWoodland ...
        (boolsMeasPtsOutOfWood) = 0;
    
    cleanedMeasPredResults.estiDistsInWoodland ...
        = measPredResults.estiDistsInWoodland (allBoolsToKeepMeas);
    
    disp('                Done!');
    
    measPredResults.ituPredictionsInDbOld = ...
        measPredResults.fsplInDb ...
        + simGridPredResults.modelItuObsByWoodland.excessLossFormula( ...
        measPredResults.estiDistsInWoodland, ...
        simGridPredResults.modelItuObsByWoodland.gammaRecommended, ...
        simGridPredResults.modelItuObsByWoodland.AmFitted);
    
    cleanedMeasPredResults.ituPredictionsInDbOld = ...
        cleanedMeasPredResults.fsplInDb ...
        + simGridPredResults.modelItuObsByWoodland.excessLossFormula( ...
        cleanedMeasPredResults.estiDistsInWoodland, ...
        simGridPredResults.modelItuObsByWoodland.gammaRecommended, ...
        simGridPredResults.modelItuObsByWoodland.AmFitted);
    
    disp(' ');
    disp('            Refitting site-specific model C...');
    % For two-step linear model for foliage area.
    allContiPathLossesWithGpsInfoCleaned ...
        = allContiPathLossesWithGpsInfo(allBoolsToKeepMeas, :);
    
    modelTwoStepLinearLossWrtFA ...
        = simGridPredResults.modelTwoStepLinearLossWrtFA;
    fctToFit = @(paraToFit, input) ...
        modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        input, paraToFit(1), paraToFit(2), paraToFit(3), paraToFit(4));
    startingPtTwoStepLinearWrtFA ...
        = [modelTwoStepLinearLossWrtFA.constPerUoFACloseFitted, ...
        modelTwoStepLinearLossWrtFA.constPerUoFAFarFitted, ...
        modelTwoStepLinearLossWrtFA.boundaryFitted, ...
        modelTwoStepLinearLossWrtFA.constShiftFitted];
    fittedRes = nlinfit( ...
        cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
        allContiPathLossesWithGpsInfoCleaned(:, 1) ...
        -cleanedMeasPredResults.fsplInDb, ...
        fctToFit, startingPtTwoStepLinearWrtFA);
    modelTwoStepLinearLossWrtFA.constPerUoFACloseFitted = fittedRes(1);
    modelTwoStepLinearLossWrtFA.constPerUoFAFarFitted = fittedRes(2);
    modelTwoStepLinearLossWrtFA.boundaryFitted = fittedRes(3);
    modelTwoStepLinearLossWrtFA.constShiftFitted = fittedRes(4);
    
    % Store the results.
    cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        = modelTwoStepLinearLossWrtFA;
    disp('                Done!');
    
    % For the ITU model, refit Am to our data.
    disp(' ');
    disp('            Refitting ITU...');
    modelItuObsByWoodland = simGridPredResults.modelItuObsByWoodland;
    fctToFit = @(amToFit, d) modelItuObsByWoodland.excessLossFormula( ...
        d, modelItuObsByWoodland.gammaRecommended, amToFit);
    modelItuObsByWoodland.AmFitted = nlinfit( ...
        cleanedMeasPredResults.estiDistsInWoodland, ...
        allContiPathLossesWithGpsInfoCleaned(:, 1) ...
        - cleanedMeasPredResults.fsplInDb, ...
        fctToFit, rand(1));
    
    % Store the results.
    cleanedMeasPredResults.modelItuObsByWoodland ...
        = modelItuObsByWoodland;
    disp('                Done!');
    
    % RMSDs compared with the simulation results.
    %     rmsdTwoStepLinearLossWrtFA = sqrt(mean( ...
    %      (allPredictedPathLossesTwoStepLinearLossWrtFA ...
    %     - allMeasPathLosses).^2));
    
    simGridPredResults.siteSpecificModelCPredictionsInDbNew ...
        = simGridPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        simGridPredResults.foliageAreasInFirstFresnel, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    measPredResults.siteSpecificModelCPredictionsInDbNew ...
        = measPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        measPredResults.foliageAreasInFirstFresnel, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbNew ...
        = cleanedMeasPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    simGridPredResults.ituPredictionsInDbNew = ...
        simGridPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelItuObsByWoodland ...
        .excessLossFormula( ...
        simGridPredResults.estiDistsInWoodland, ...
        cleanedMeasPredResults.modelItuObsByWoodland.gammaRecommended, ...
        cleanedMeasPredResults.modelItuObsByWoodland.AmFitted);
    
    measPredResults.ituPredictionsInDbNew = ...
        measPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelItuObsByWoodland ...
        .excessLossFormula( ...
        measPredResults.estiDistsInWoodland, ...
        cleanedMeasPredResults.modelItuObsByWoodland.gammaRecommended, ...
        cleanedMeasPredResults.modelItuObsByWoodland.AmFitted);
    
    cleanedMeasPredResults.ituPredictionsInDbNew = ...
        cleanedMeasPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelItuObsByWoodland ...
        .excessLossFormula( ...
        cleanedMeasPredResults.estiDistsInWoodland, ...
        cleanedMeasPredResults.modelItuObsByWoodland.gammaRecommended, ...
        cleanedMeasPredResults.modelItuObsByWoodland.AmFitted);
    
    save(pathToSavePredictionsForGrid, ...
        'measPredResults', 'cleanedMeasPredResults', 'simGridPredResults');
end

% Overview for the clearance zone around the TX.
allPLValues = [simGridPredResults.fsplInDb; ...
    simGridPredResults.ituPredictionsInDbOld; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
plRange = [floor(min(allPLValues)./10) ceil(max(allPLValues)./10)].*10;

hFigOverviewForClearanceZone = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, simGridPredResults.fsplInDb], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'FSPL (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ = max(simGridPredResults.fsplInDb)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
hClearanceZone = fill3( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
    ones(length( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1) ...
    )).*higherLayerZ, 'w');
alpha(hClearanceZone, 0.5); axis tight;
view(2);
legend([hTx, hTrees(1), hClearanceZone(1)], ...
    'TX', 'Trees', 'Clear zone', ...
    'Location', 'southeast');
plot_google_map('MapType', 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForClearanceZone.png');
saveas(hFigOverviewForClearanceZone, curFigPath);

% Overview of the results from ITU.
hFigOverviewForItu = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbOld], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old ITU (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ = max(simGridPredResults.ituPredictionsInDbOld)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
hClearanceZone = fill3( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
    ones(length( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1) ...
    )).*higherLayerZ, 'w');
alpha(hClearanceZone, 0.5); axis tight;
view(2);
legend([hTx, hTrees(1), hClearanceZone(1)], ...
    'TX', 'Trees', 'Clear zone', ...
    'Location', 'southeast');
% plot_google_map('MapType', 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForItu.png');
saveas(hFigOverviewForItu, curFigPath);

% Overview of the results from site-specific model C.
hFigOverviewForSiteSpecificC = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old SS-C (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simGridPredResults.siteSpecificModelCPredictionsInDbOld)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSiteSpecificC, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSiteSpecificC.png');
saveas(hFigOverviewForSiteSpecificC, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Model Prediction Comparisons

disp(' ');
disp('    Comparisons with the simulation results for the big grid...');

MULTIPLICATION_FACTOR = 1;

% The simulation results for the extended RX location grid.
simPLsForGridOrig ...
    = loadSimLossFromExcel(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID, ...
    MULTIPLICATION_FACTOR);
% simResultsForGridTable = readtable(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
%  simPLsForGridOrig = simResultsForGridTable.simLoss_dB_;

[~, curSimResultsForGridFilename] ...
    = fileparts(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
if strcmpi(curSimResultsForGridFilename, ...
        'var_grnd_grid_propagation_stats_20191026')
    simPLsForGrid = nan(5742, 1);
    simPLsForGridIndices = simResultsForGridTable.id;
    simPLsForGrid(simPLsForGridIndices) = simPLsForGridOrig;
else
    simPLsForGrid = simPLsForGridOrig;
end


[~, gridRawDataFilename, ~] ...
    = fileparts(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
if strcmp(gridRawDataFilename, 'var_grnd_grid_propagation_stats_20191026' )
    % For now, the const values of ~263 shown in simPLsForGrid are not
    % valide.
    simPLsForGrid(simPLsForGrid==simPLsForGrid(1)) = nan;
end

% Calibrate the simulation results for the grid.
switch lower(simGridLossCalibMethod)
    case 'fspl'
        % Fit simulation results to FSPL at 1 m reference point. First,
        % find the index for the LoS 1-m close-in reference point.
        CLOSE_IN_REF_POINT_DIST_IN_M = 1;
        
        boolsGridPtsOutofWood = inpolygon(simGridLons, simGridLats, ...
            simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2),...
            simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
        distsToTxInM3dOutOfWood = simGridPredResults.distsToTxInM3d;
        distsToTxInM3dOutOfWood(~boolsGridPtsOutofWood) = inf;
        
        [curMinDistDiff, idxForCloseInRefGridPt] = min(abs( ...
            simGridPredResults.distsToTxInM3d ...
            - CLOSE_IN_REF_POINT_DIST_IN_M));
        
        [xCloseInRefGridPt, yCloseInRefGridPt] = deg2utm( ...
            simGridLats(idxForCloseInRefGridPt), ...
            simGridLons(idxForCloseInRefGridPt));
        distTxToCloseInRefGridPt = norm([xTx, yTx] ...
            - [xCloseInRefGridPt, yCloseInRefGridPt]);
        fsplCloseInRefGridPt ...
            = simGridPredResults.fsplInDb(idxForCloseInRefGridPt);
        simGridPlShiftAmount = fsplCloseInRefGridPt ...
            - simPLsForGrid(idxForCloseInRefGridPt);
        simPLsForGridCalibrated = simPLsForGrid + simGridPlShiftAmount;
    case 'cleanedmeas'
        simLossForMeas = cell(numOfTracks,1);
        for idxTrack = 1:numOfTracks
            curDirToLoadSimResults ...
                = dirsToLoadSimResultsForEachTrack{idxTrack};
            if ~isempty(curDirToLoadSimResults)
                simLossForMeas{idxTrack} ...
                    = loadSimLossFromExcel(curDirToLoadSimResults, ...
                    MULTIPLICATION_FACTOR);
                
                assert(all(~isnan(simLossForMeas{idxTrack})), ...
                    'NaN value found in simulation results!');
            end
        end
        allSimPlForMeas = vertcat(simLossForMeas{:});
        allSimPlForMeasCleaned = allSimPlForMeas(allBoolsToKeepMeas);
        
        allContiPathLossesWithGpsInfo ...
            = vertcat(contiPathLossesWithGpsInfo{:});
        allContiPathLossesWithGpsInfoCleaned ...
            = allContiPathLossesWithGpsInfo(allBoolsToKeepMeas, :);
        curMeasLosses = allContiPathLossesWithGpsInfoCleaned(:,1);
        expectedNumOfSamps = length(curMeasLosses);
        curSimLoss = allSimPlForMeasCleaned;
        
        [curCalibratedSim, curBestShift, curMultiFactor] ...
            = calibrateSimPlsWithMeas(curSimLoss, curMeasLosses);
        
        % Plot RMSD vs shift around the best shift value.
        curFigFilenamePrefix = 'SimVsMeas_MeasCleaned';
        
        hFigRmsdInspection = figure('visible', ~flagGenFigSilently);
        hold on;
        xs = minShift:0.1:maxShift;
        ys = arrayfun(@(x) sqrt(mseFct(x)), xs);
        plot(xs, ys, '.-');
        bestRmsd = sqrt(mseFct(curBestShift));
        if ~isempty(curBestShift)
            hMin = plot(curBestShift, bestRmsd, 'r*');
        end
        xlabel('Shift Value (dB)'); ylabel('RMSD (dB)');
        grid on; grid minor; axis equal;
        legend('Best shift value');
        title({['shift = ', ...
            num2str(curBestShift, '%.2f'), ' dB, multiFactor = ', ...
            num2str(curMultiFactor, '%.2f')]; ...
            ['Best RMSD = ', num2str(bestRmsd, '%.2f'), ' dB']});
        pathToSaveCurFig = fullfile(curAbsPathToSavePlots, ...
            [curFigFilenamePrefix, '_RmsdInspection_Track_', ...
            num2str(idxTrack), '.png']);
        
        saveas(hFigRmsdInspection, pathToSaveCurFig);
        
        % Plot simulation results with measurements.
        hFigSimVsMeasByIdx = figure('visible', ~flagGenFigSilently);
        hold on;
        hSim = plot(1:expectedNumOfSamps, curCalibratedSim, 'x');
        hMeas = plot(1:expectedNumOfSamps, curMeasLosses, '.');
        xlabel('Sample'); ylabel('RMSD (dB)');
        grid on; grid minor; axis tight;
        if ~isempty(hSim)
            legend([hSim, hMeas], 'Simulation', 'Measurement');
        end
        pathToSaveCurFig = fullfile(curAbsPathToSavePlots, ...
            [curFigFilenamePrefix, '_PlVsSampIdx_MeasCleaned', ...
            num2str(idxTrack), '.png']);
        
        saveas(hFigSimVsMeasByIdx, pathToSaveCurFig);
        
        % Load history TX to RX distance.
        rxToTx3DDistInM = cell(numOfTracks,1);
        for idxTrack = 1:numOfTracks
            curRxLocCsv = readtable(fullfile(ABS_PATH_TO_SIM_CSV_FILES, ...
                ['rxLoc_meas_', num2str(idxTrack), '.csv']));
            rxToTx3DDistInM{idxTrack} ...
                = curRxLocCsv.rxToTx3DDistInM(boolsToKeepMeas{idxTrack});
        end
        curRxToTx3DDistInM = vertcat(rxToTx3DDistInM{:});
        
        % Another comparison figure with TX-to-RX distance as the x axis.
        [xs, indicesSortByDist] = sort(curRxToTx3DDistInM);
        
        hFigSimVsMeasByDist = figure('visible', ~flagGenFigSilently);
        hold on;
        if ~isempty(xs)
            hSim = plot(xs, curCalibratedSim(indicesSortByDist), 'x-');
            hMeas = plot(xs, curMeasLosses(indicesSortByDist), '.--');
        end
        xlabel('3D RX-to-TX Distance (m)'); ylabel('RMSD (dB)');
        grid on; grid minor; axis tight;
        if ~isempty(hSim)
            legend([hSim, hMeas], 'Simulation', 'Measurement', ...
                'Location', 'SouthEast');
        end
        pathToSaveCurFig = fullfile(curAbsPathToSavePlots, ...
            [curFigFilenamePrefix, '_PlVsDist_MeasCleaned', ...
            num2str(idxTrack), '.png']);
        
        saveas(hFigSimVsMeasByDist, pathToSaveCurFig);
        
        simGridPlShiftAmount = curBestShift;
        simGridPlMultiFactor = curMultiFactor;
        simPLsForGridCalibrated = simPLsForGrid.*curMultiFactor ...
            + simGridPlShiftAmount;
    otherwise
        error(['Unknown calibration method: ', simGridLossCalibMethod]);
end

% Overview of the simulation results.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simPLsForGridCalibrated], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Sim Results (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForGrid.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of FSPL.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.fsplInDb], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'FSPL (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForFspl.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the simulation results full range.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simPLsForGridCalibrated], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Sim Results (dB)'}, ...
    'ColorRange', [ceil(max(simPLsForGridCalibrated)), ...
    floor(min(simPLsForGridCalibrated))]);
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForGrid_FullRange.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference between the ITU predictions and the simulation
% results.
ituVsSimZsOld = simGridPredResults.ituPredictionsInDbOld ...
    - simPLsForGridCalibrated;
sscVsSimZsOld = simGridPredResults.siteSpecificModelCPredictionsInDbOld ...
    - simPLsForGridCalibrated;
ituVsSimZsNew = simGridPredResults.ituPredictionsInDbNew ...
    - simPLsForGridCalibrated;
sscVsSimZsNew = simGridPredResults.siteSpecificModelCPredictionsInDbNew ...
    - simPLsForGridCalibrated;
fspsVsSimZs = simGridPredResults.fsplInDb - simPLsForGridCalibrated;

% Shift the new ITU and site-specific C results to see what the best fit
% will look like.

% We will treat the simulation results as the ground truth and calibrate
% the model predictions to see the best poissible agreement that could be
% achieved. First, for the site-specific C model.
curMeasLosses = simPLsForGridCalibrated;
curSimLoss = simGridPredResults.siteSpecificModelCPredictionsInDbNew;

[simGridPredResults.siteSpecificModelCPredictionsInDbNewCalibrated, ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedShift, ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedMultiFactor] ...
    = calibrateSimPlsWithMeas(curSimLoss, curMeasLosses);

sscVsSimZsNewShifted ...
    = simGridPredResults.siteSpecificModelCPredictionsInDbNewCalibrated ...
    - simPLsForGridCalibrated;

% Now for the ITU model.
curMeasLosses = simPLsForGridCalibrated;
curSimLoss = simGridPredResults.ituPredictionsInDbNew;

[simGridPredResults.ituPredictionsInDbNewCalibrated, ...
    simGridPredResults.ituPredictionsInDbNewCalibratedShift, ...
    simGridPredResults.ituPredictionsInDbNewCalibratedMultiFactor] ...
    = calibrateSimPlsWithMeas(curSimLoss, curMeasLosses);

ituVsSimZsNewShifted = simGridPredResults.ituPredictionsInDbNewCalibrated ...
    - simPLsForGridCalibrated;

% For plotting in the same path loss range.
curPLDiffs = [ituVsSimZsOld; sscVsSimZsOld; ...
    ituVsSimZsNew; sscVsSimZsNew; fspsVsSimZs; ...
    sscVsSimZsNewShifted; ituVsSimZsNewShifted];

% curColorRange = [ceil(max(curPLDiffs)), floor(min(curPLDiffs))];
curColorRange = [0, ceil(max(abs(curPLDiffs)))];

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, ituVsSimZsOld], ...
    'Old ITU', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridOldItuVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference between the site-specific C predictions and
% the simulation results.
hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, sscVsSimZsOld], ...
    'Old SS-C', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridOldSiteSpecificCVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference for the new model fitting results.
hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, ituVsSimZsNew], ...
    'New ITU', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewItuVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, sscVsSimZsNew], ...
    'New SS-C', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewSiteSpecificCVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, fspsVsSimZs], ...
    'FSPL', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridFsplVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% For the calibrated (according to the model predictions) ones.
hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, ituVsSimZsNewShifted], ...
    'New ITU Shifted', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);
figure(hFigOverviewForSimPLsForGrid);
hTitleStr = get(get(gca, 'title'), 'string');
title({['shift = ', num2str( ...
    simGridPredResults ...
    .ituPredictionsInDbNewCalibratedShift), ...
    ' dB, multiFactor = ', num2str( ...
    simGridPredResults ...
    .ituPredictionsInDbNewCalibratedMultiFactor)]; ...,
    hTitleStr});
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewItuCalibratedVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigSimPLsCalibratedForGrid= figure; hold on;
hOldSim = plot(simGridPredResults.distsToTxInM3d, ...
    simPLsForGridCalibrated, 'r*');
hSimCaliByItu = plot(simGridPredResults.distsToTxInM3d, ...
    simGridPredResults ...
    .ituPredictionsInDbNewCalibrated, 'go');
hItu = plot(simGridPredResults.distsToTxInM3d, simGridPredResults ...
    .ituPredictionsInDbNew, 'b.');
legend([hOldSim, hSimCaliByItu, hItu], 'Sim', 'Sim Cali by ITU', 'ITU');
grid on; grid minor;
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'ccomparisonForGridNewSiteSpecificCCalibratedVsSim_PlOverDist.png');
saveas(hFigSimPLsCalibratedForGrid, curFigPath);

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, sscVsSimZsNewShifted], ...
    'New SS-C Shifted', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);
figure(hFigOverviewForSimPLsForGrid);
hTitleStr = get(get(gca, 'title'), 'string');
title({['shift = ', num2str( ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedShift), ...
    ' dB, multiFactor = ', num2str( ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedMultiFactor)]; ...,
    hTitleStr});
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewSiteSpecificCCalibratedVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigSimPLsCalibratedForGrid= figure; hold on;
hOldSim = plot(simGridPredResults.distsToTxInM3d, ...
    simPLsForGridCalibrated, 'r*');
hSimCaliBySsc = plot(simGridPredResults.distsToTxInM3d, simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibrated, 'go');
hSsc = plot(simGridPredResults.distsToTxInM3d, simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibrated, 'b.');
legend([hOldSim, hSimCaliBySsc, hSsc], 'Sim', 'Sim Cali by SS-C', 'SS-C');
grid on; grid minor;
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewItuCalibratedVsSim_PlOverDist.png');
saveas(hFigSimPLsCalibratedForGrid, curFigPath);

% Plot diff vs TX-to-RX distance.
hFigDiffVsTxToRxDist = figure('visible', ~flagGenFigSilently);
hold on; alphaToSet = 1;
hFSPL = scatter(simGridPredResults.distsToTxInM3d, fspsVsSimZs, '*', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
hITU = scatter(simGridPredResults.distsToTxInM3d, ituVsSimZsOld, '^', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
hSSC = scatter(simGridPredResults.distsToTxInM3d, sscVsSimZsOld, '.', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
title('Difference between Model Predictions and Simulation Results');
legend([hFSPL, hITU, hSSC], 'FSPL', 'ITU', 'Site-Specific C');
grid on;

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'predictionSimDiffVsDistToTx.png');
saveas(hFigDiffVsTxToRxDist, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Extra Plots

disp('    Generating extra plots...');

% We will use surf for the path loss results.
simConfigs.UTM_X_Y_BOUNDARY_OF_INTEREST ...
    = simGrid.xYRangePolyshape.Vertices;
simConfigs.utm2deg_speZone = @(x, y) utm2deg(x, y, ...
    repmat(simGrid.utmZone, length(x),1));
simConfigs.deg2utm_speZone = @(lon, lat) deg2utm(lon, lat);
simConfigs.CURRENT_SIMULATION_TAG = 'NistForestGrid';
simConfigs.NUM_OF_PIXELS_FOR_LONGER_SIDE ...
    = simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE;
flagVisible = ~flagGenFigSilently;
txLonLats = [lonTx, latTx];
flagZoomIn = true;

allPathlossValues = [simGridPredResults.fsplInDb; ...
    simPLsForGridCalibrated; simGridPredResults.ituPredictionsInDbOld; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld; ...
    simGridPredResults.ituPredictionsInDbNew; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew];
simConfigs.ALLOWED_PATH_LOSS_RANGE_IN_DB ...
    = [floor(min(allPathlossValues)./10), ...
    ceil(max(allPathlossValues)./10)].*10;

% Overview of FSPL.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.fsplInDb];
colorbarTitle = 'FSPL (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSimPLsForFspl.png');
saveas(hCurPLMap, curFigPath);

% Overview of the simulation results.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simPLsForGridCalibrated];
colorbarTitle = 'Sim Results (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSimPLsForGrid.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from ITU.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbOld];
colorbarTitle = 'Old ITU (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForItu.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from site-specific model C.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
colorbarTitle = 'Old SS-C (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSiteSpecificC.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from ITU (new).
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbNew];
colorbarTitle = 'New ITU (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForItuNew.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from site-specific model C (new)..
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew];
colorbarTitle = 'New SS-C (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSiteSpecificCNew.png');
saveas(hCurPLMap, curFigPath);

% For site-specific C model on measurements: path loss vs foliage area.
hFigPlOverAf = figure('visible', ~flagGenFigSilently); hold on;
% All measurements.
hAllMeas = plot(measPredResults.foliageAreasInFirstFresnel, ...
    measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - measPredResults.fsplInDb, 'or');
% Cleaned measurements.
hCleanedMeas = plot(cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
    cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - cleanedMeasPredResults.fsplInDb, '*b');
% Old SSC.
hOldSsc = plot(measPredResults.foliageAreasInFirstFresnel, ...
    measPredResults.siteSpecificModelCPredictionsInDbOld ...
    - measPredResults.fsplInDb, '.k');
% New SSC.
hNewSsc = plot(cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbNew ...
    - cleanedMeasPredResults.fsplInDb, '.g');
axis tight; xlabel('Foliage Area (m^2)'); ylabel('Excess Path Loss (dB)');
grid on; grid minor;
legend([hAllMeas, hCleanedMeas, hOldSsc, hNewSsc], ...
    'All measurements', 'Cleaned measurements', 'Old SS-C', 'New SS-C', ...
    'Location', 'southeast');
rmseOld = sqrt(sum(( ...
    measPredResults.siteSpecificModelCPredictionsInDbOld ...
    - measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(measPredResults.ituPredictionsInDbOld));
rmseNew = sqrt(sum(( ...
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbNew ...
    - cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(cleanedMeasPredResults.ituPredictionsInDbOld));
title({['Old RMSE = ', num2str(rmseOld), ' dB']; ...
    ['New RMSE = ', num2str(rmseNew), ' dB']});

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'fittedModelSiteSpecificC.png');
saveas(hFigPlOverAf, curFigPath);

% For the ITU model on measurements: path loss vs woodland distance.
hFigPlOverDw = figure('visible', ~flagGenFigSilently); hold on;
% All measurements.
hAllMeas = plot(measPredResults.estiDistsInWoodland, ...
    measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - measPredResults.fsplInDb, 'or');
% Cleaned measurements.
hCleanedMeas = plot(cleanedMeasPredResults.estiDistsInWoodland, ...
    cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - cleanedMeasPredResults.fsplInDb, '*b');
% Old ITU.
hOldSsc = plot(measPredResults.estiDistsInWoodland, ...
    measPredResults.ituPredictionsInDbOld ...
    - measPredResults.fsplInDb, '.k');
% New ITU.
hNewSsc = plot(cleanedMeasPredResults.estiDistsInWoodland, ...
    cleanedMeasPredResults.ituPredictionsInDbNew ...
    - cleanedMeasPredResults.fsplInDb, '.g');
axis tight; xlabel('Woodland Distance (m)');
ylabel('Excess Path Loss (dB)');
grid on; grid minor;
legend([hAllMeas, hCleanedMeas, hOldSsc, hNewSsc], ...
    'All measurements', 'Cleaned measurements', 'Old ITU', 'New ITU', ...
    'Location', 'southeast');
rmseOld = sqrt(sum(( ...
    measPredResults.ituPredictionsInDbOld ...
    - measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(measPredResults.ituPredictionsInDbOld));
rmseNew = sqrt(sum(( ...
    cleanedMeasPredResults.ituPredictionsInDbNew ...
    - cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(cleanedMeasPredResults.ituPredictionsInDbOld));
title({['Old RMSE = ', num2str(rmseOld), ' dB']; ...
    ['New RMSE = ', num2str(rmseNew), ' dB']});

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'fittedModelItu.png');
saveas(hFigPlOverDw, curFigPath);

% For site-specific C model on grid: foliage area on map.
hFigAfOnMapForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap jet;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.foliageAreasInFirstFresnel], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Foliage Area (m^2)'});
higherLayerZ ...
    = max(simGridPredResults.foliageAreasInFirstFresnel)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
axis tight;
view(2);
legend(hTx, 'TX', 'Location', 'southeast');
plotGoogleMapAfterPlot3k(hFigAfOnMapForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'gridAfOnMap.png');
saveas(hFigAfOnMapForGrid, curFigPath);

% For ITU and site-specific C vs simulation results on the grid, we
% generate the RMSE vs RX-to-TX figure, treating the simulation results as
% ground truth.
groundTruthPlValues = simPLsForGridCalibrated;
rxToTxDistsInM3d = simGridPredResults.distsToTxInM3d;

% All path losses.
hFigPathLossOverDist = figure('visible', ~flagGenFigSilently); hold on;
hSim = plot(rxToTxDistsInM3d, groundTruthPlValues, 'bo');
hModSsc = plot(rxToTxDistsInM3d, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew, 'r*');
hModItu = plot(rxToTxDistsInM3d, ...
    simGridPredResults.ituPredictionsInDbNew, 'g.');
legend([hSim, hModItu, hModSsc], ...
    'Simulation', 'New ITU', 'New SS-C', 'Location', 'southeast');
grid on; grid minor;
xlabel('RX to TX distance (m)'); ylabel('Path loss (dB)');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'allPlsOverDist.png');
saveas(hFigPathLossOverDist, curFigPath);

% Shifting-window RMSE.
WINDOW_SIZE_IN_M = 10; % Needs to be an even number.

modelPredictions ...
    = simGridPredResults.siteSpecificModelCPredictionsInDbNew;

curXs = floor(min(rxToTxDistsInM3d+WINDOW_SIZE_IN_M/2)) ...
    :1:ceil(max(rxToTxDistsInM3d-WINDOW_SIZE_IN_M/2));
numOfCurXs = length(curXs);
[rmsesSscNew, rmsesItuNew] = deal(nan(numOfCurXs,1));
rmseFct = @(diff) sqrt(mean( diff.^2 ));
for idxX = 1:numOfCurXs
    curX = curXs(idxX);
    curXRangeMin = curX-WINDOW_SIZE_IN_M/2;
    curXRangeMax = curX+WINDOW_SIZE_IN_M/2;
    boolsGridPtsInCurRange = (rxToTxDistsInM3d>=curXRangeMin) ...
        & (rxToTxDistsInM3d<=curXRangeMax);
    rmsesSscNew(idxX) = rmseFct(sscVsSimZsNew(boolsGridPtsInCurRange));
    rmsesItuNew(idxX) = rmseFct(ituVsSimZsNew(boolsGridPtsInCurRange));
end

hFigWindowedRmse = figure('visible', ~flagGenFigSilently); hold on;
hItuNew = plot(curXs, rmsesItuNew, 'r*--');
hSscNew = plot(curXs, rmsesSscNew, 'b.-');
grid on; grid minor;
xlabel('RX to TX distance (m)'); ylabel('Windowed RMSE (dB)');
legend([hItuNew, hSscNew], ...
    'New ITU', 'New SS-C', 'Location', 'southeast');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'windowedRmse.png');
saveas(hFigPathLossOverDist, curFigPath);

% For site-specific C model on measurements: path loss vs RX-to-TX
% distance. We will plot both the results for the old parameter values and
% those for the new parameter values.

% For ITU on measurements: path loss vs RX-to-TX distance. We will plot
% both the results for the old parameter values and those for the new
% parameter values.

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Save Workspace for Manual Inspection
disp('    Saving workspace for future inspectation...')
save(fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'workspace.mat'));
disp('    Done!');

% EOF