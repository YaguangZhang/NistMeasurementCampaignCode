%EVALPERFBASEDONSIMRESULTS Evaluation the performance of site-specific
%models according to the simulation results from CSLabs.
%
% Yaguang Zhang, Purdue, 09/13/2019

clearvars -except getUsgsEleInMFromUtmXY; clc; close all;

%% Configurations

warning('on');

% Add libs to current path and set ABS_PATH_TO_NIST_SHARED_FOLDER according
% to the machine name.
cd(fileparts(mfilename('fullpath')));
addpath(fullfile(pwd));
cd('..'); setPath;

% We will need computeFreeSpacePathLosses.m.
addpath(fullfile(pwd, '4_FoliageAttenuationEstimation'));

% We will need the functions latLon2PixIndices.m and pixIndices2LatLon.m
% for working with the vegArea image.
addpath(fullfile(pwd, '9_GenerateVegAreas'));

% We will need the functions countNumOfFoliagePixelsInFirstFresnelZone.m
addpath(fullfile(pwd, '10_CompareFoliageDepthBasedModels'));

% Path to the simulation result xlsx files.
ABS_DIR_TO_SIM_RESULTS = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'Data', '20191011_NistFoliageSimulationResults');

% Path to the simulation result xlsx files.
ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'Data', '20191016_NistFoliageSimulationResultsForGrid', ...
    'var_grnd_grid_propagation_stats_20191029.xlsx');
% 'var_grnd_grid_propagation_stats_20191029.xlsx' or
% 'var_grnd_grid_propagation_stats_20191102.xlsx'.

% Configure other paths accordingly.
ABS_PATH_TO_SAVE_PLOTS = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PerformanceEvaluationBasedOnSimulations');

% Reuse results from evalPathLossesForContiTracks.m and
% loadMeasCampaignInfo.m.
ABS_PATH_TO_PATH_LOSSES_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputationConti', ...
    'contiPathLossesWithGpsInfo.mat');
ABS_PATH_TO_TX_INFO_LOGS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputation', 'txInfoLogs.mat');

% Reuse results from generateVegAreas.m.
ABS_PATH_TO_VEG_AREAS_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'AutoGeneratedVegAreas', 'vegAreasMeta.mat');

% Reuse results from estimateFoliageAttenuation.m.
ABS_PATH_TO_UTM_INFO_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'FoliageAttenuationEstimation', ...
    'utmInfoForPathLossesAndTrees.mat');

% Reuse results from estimateFoliageAttenuationWithManualTreeLocs.m.
ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageAttenuationEstimation_ManualTreeLocs', ...
    'foliageAttenAnalysisResults.mat');

% Reuse results from compareFoliageDepthBasedModels.m.
ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageDepthBasedModelsComparison', ...
    'foliageDepthBasedAttenAnalysisResults.mat');

% Reuse results from inspectOutlayers.m.
ABS_PATH_TO_BEAM_POLYGONS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    '13_OutlayerInspection', ...
    'beamPolygons.mat');

% Reuse .csv files exported for simulation.
ABS_PATH_TO_SIM_CSV_FILES ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'SimulationDataExportationExtended');

% The lengths of path within woodland (for the ITU model) and site-specific
% foilage areas will be saved into a file.
pathToSavePredictionsForGrid ...
    = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'predictionsForExtendedGrid.mat');

% The predictions from selected models will be saved.
pathToSaveGrid ...
    = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simulationGrid.mat');

% The 3 segment for length of path within woodland for evaluating the
% performance (root-mean-square deviation) for the ITU model. Each segment
% will be the min and max values in the form of [min, max), i.e. including
% min but excluding max.
segmentsForRmsdDw = {[0,30], [30,220], [220, inf]};

% The 3 segment for the foliage depth for evaluating the performance of
% Weissberger's model. Each segment will be the min and max values in the
% form of [min, max), i.e. including min but excluding max.
segmentsForRmsdDf = {[0,15], [15,75], [75, inf]};

% The updated tree locations.
ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'ManuallyLocateMoreTrees', 'treeLocs.mat');

% For creating a grid to cover a larger area than that covered by our
% measurements. We will need the (latitude, longitude) range polygon stored
% as a polyshape to determin which area to cover.
latLonEdgesDeterminedByTerrain = {[39.992772, -105.275100; ...
    39.990018, -105.278469]; ...
    [39.989118, -105.276475; ...
    39.991211, -105.272842]};

% Control the truncation of the data in the output .csv files.
dataStrFormatter = '%.12f';

% For plotting.
lightGray = ones(1,3).*0.7;

% We will use this number of pixels for the longer side (width/height) of
% the simulation area; the number of pixels for the other side will be
% proportional to its length.
simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE = 100;

% For plotting.
areaOfInterestColor = [0.9290 0.6940 0.1250];
lightBlue = [0.3010 0.7450 0.9330];
darkBlue = [0 0.4470 0.7410];

% Set this to true to avoid showing the figures while they are being
% generated.
flagGenFigSilently = true;

% The measurement area.
figAxisToSet = [-105.2774429259207, -105.2744429246357, ...
    39.9893839683981, 39.9915745444857];

% Calibrate the simulation results for the grid according to close-in
% 'FSPL', 'cleanedMeas', 'trackOneOnGrid', or 'cleanedMeasOnGrid':
%   - FSPL
%     We will find a close-in reference point and shift the simulation
%     results for the grid as a whole so that at the reference point the
%     simulation result will agree with FSPL.
%   - cleanedMeas
%     We will find a shift for the whole grid simulation results according
%     to the best shift and multiplication factor from the simulation
%     results for the cleaned data set.
%   - trackOneOnGrid
%     We will find the nearest neighbor grid point for each measurement
%     location on track 1 and calibrate the grid simulation results
%     according to those on the fetched locations (compared to the cleaned
%     measurement data).
%   - cleanedMeasOnGrid
%     Similar to 'trackOneOnGrid', but instead of using only track 1, we
%     will use all the cleaned measurement data.
simGridLossCalibMethod = 'cleanedMeasOnGrid';

%% Before Processing the Data

curFileName = mfilename;
fileNameHintRuler = [' ', repmat('-', 1, length(curFileName)+2), ' '];
disp(fileNameHintRuler)
disp(['  ', curFileName, '  '])
disp(fileNameHintRuler)

% Create directories if necessary.
if exist(ABS_PATH_TO_SAVE_PLOTS, 'dir')~=7
    mkdir(ABS_PATH_TO_SAVE_PLOTS);
end

%% Get Info for Measurement Data Files and Calibration Polynomials

disp(' ')
disp('    Loading results from: ')
disp('      - contiPathLossesWithGpsInfo.mat')
disp('      - txInfoLogs.mat')
disp('      - vegAreasMeta.mat')
disp('      - utmInfoForPathLossesAndTrees.mat')
disp('      - treeLocs.mat (Extended)')

assert(exist(ABS_PATH_TO_PATH_LOSSES_FILE, 'file')==2, ...
    'Couldn''t find contiPathLossesWithGpsInfo.mat! Please run 3_PathLossComputation/evalPathLossesForContiTracks.m first.');
assert(exist(ABS_PATH_TO_TX_INFO_LOGS_FILE, 'file')==2, ...
    'Couldn''t find txInfoLogs.mat! Please run 3_PathLossComputation/loadMeasCampaignInfo.m first.');
assert(exist(ABS_PATH_TO_VEG_AREAS_FILE, 'file')==2, ...
    'Couldn''t find vegAreasMeta.mat! Please run 9_GenerateVegAreas/generateVegAreas.m first.');
assert(exist(ABS_PATH_TO_UTM_INFO_FILE, 'file')==2, ...
    'Couldn''t find utmInfoForPathLossesAndTrees.mat! Please run 4_FoliageAttenuationEstimation/estimateFoliageAttenuation.m first.');
assert(exist(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE, 'file')==2, ...
    'Couldn''t find foliageAttenAnalysisResults.mat! Please run 8_FoliageAttenuationEstimation_ManualTreeLocs/estimateFoliageAttenuationWithManualTreeLocs.m first.');
assert(exist(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, 'file')==2, ...
    'Couldn''t find foliageDepthBasedAttenAnalysisResults.mat! Please run 10_CompareFoliageDepthBasedModels/compareFoliageDepthBasedModels.m first.');
assert(exist(ABS_PATH_TO_BEAM_POLYGONS_FILE, 'file')==2, ...
    'Couldn''t find beamPolygons.mat! Please run 13_OutlayerInspection/inspectOutlayers.m first.');
assert(exist(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS, 'file')==2, ...
    'Couldn''t find treeLocs.mat! Please run NistMeasurementCampaignCode/15_PerfEvaluationBasedOnSim/manuallyLocateMoreTrees.m first.');

% The data have been processed before and the result files have been found.
disp('    Found all .mat files required.');
disp('        Loading the results...');

% Get 'contiPathLossesWithGpsInfo', 'contiOutFilesRelPathsUnderDataFolder'
% and 'contiOutFileIndicesReflection'.
load(ABS_PATH_TO_PATH_LOSSES_FILE);
% Get records of the TxInfo.txt files (among other contant parameters for
% the measurement campaign, e.g. F_S, TX_LAT, TX_LON, and TX_POWER_DBM):
% 	'TX_INFO_LOGS' and 'TX_INFO_LOGS_ABS_PAR_DIRS'.
load(ABS_PATH_TO_TX_INFO_LOGS_FILE);
% Get 'vegAreas', 'LAT_RANGE', 'LON_RANGE', 'VEG_AREA_IMG_RESOLUTION', and
% 'VEG_AREA_IMG_META'.
load(ABS_PATH_TO_VEG_AREAS_FILE);
% Get 'xTx', 'yTx', 'txUtmZone', 'treeLocations', 'pathLossUtmXYHs',
% 'pathLossUtmZones', 'treeUtmXYHs', and 'treeUtmZones'.
load(ABS_PATH_TO_UTM_INFO_FILE);
% Get 'numsOfTreesInFirstFresnel', 'freeSpacePathLosses',
% 'exceLossRefFreeSpace', 'excePathLossPerTree',
% 'shiftedFreeSpacePathLosses', 'excePathLossGroupWise', and
% 'groupWiseShiftedFreeSpacePathLosses'.
load(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE);
% Get 'modelTwoStepLinearLossWrtWFA' and all other site-specific models.
load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE);
% Get 'modelTwoStepLinearLossWrtWFA' and all other site-specific models.
load(ABS_PATH_TO_BEAM_POLYGONS_FILE);
% Get 'markLocs'.
load(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS);

disp('    Done!');

%% Create the Grid

disp(' ');
disp('    Generating extended RX location grid...');

% Create the grid in (lon, lat).
lonsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,2)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,2)'];
latsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,1)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,1)'];

lonVegArealimit = VEG_AREA_IMG_META.LON_RANGE;
latVegArealimit = VEG_AREA_IMG_META.LAT_RANGE;
lonsVegAreaPolygon = lonVegArealimit([1 1 2 2 1]);
latsVegAreaPolygon = latVegArealimit([1 2 2 1 1]);

[lonsEdgeIntersection, latsEdgeIntersection] = polyxpoly( ...
    lonsVegAreaPolygon, latsVegAreaPolygon, ...
    lonsEdgesDeterminedByTerrain, latsEdgesDeterminedByTerrain);

latLonRangePolyVertices = convexHull( ...
    [lonsEdgeIntersection latsEdgeIntersection; ...
    lonVegArealimit' latVegArealimit']);

if exist(pathToSaveGrid, 'file')
    histSimGridResults ...
        = load(pathToSaveGrid, 'simGrid');
else
    histSimGridResults.simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE = nan;
end

if histSimGridResults.simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE ...
        == simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE
    simGrid = histSimGridResults.simGrid;
else
    simGrid.latLonRangePolyshape = polyshape(latLonRangePolyVertices);
    
    % Convert to UTM (x, y).
    [xRangePolyVertices, yRangePolyVertices, utmZonesPoly] = deg2utm( ...
        latLonRangePolyVertices(:,2), latLonRangePolyVertices(:,1));
    simGrid.xYRangePolyshape = polyshape( ...
        [xRangePolyVertices yRangePolyVertices]);
    
    simGrid.utmZone = utmZonesPoly(1,:);
    
    % Construct the grid accordingly.
    simAreaMinX = min(simGrid.xYRangePolyshape.Vertices(:,1));
    simAreaMaxX = max(simGrid.xYRangePolyshape.Vertices(:,1));
    simAreaMinY = min(simGrid.xYRangePolyshape.Vertices(:,2));
    simAreaMaxY = max(simGrid.xYRangePolyshape.Vertices(:,2));
    
    simAreaWidthInM = simAreaMaxX-simAreaMinX;
    simAreaHeightInM = simAreaMaxY-simAreaMinY;
    
    gridResolution = max([simAreaWidthInM, simAreaHeightInM]) ...
        ./simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE;
    simGrid.resolutionInM = gridResolution;
    
    simAreaXLabels = constructAxisGrid( ...
        mean([simAreaMaxX, simAreaMinX]), ...
        floor((simAreaMaxX-simAreaMinX)./gridResolution), gridResolution);
    simAreaYLabels = constructAxisGrid( ...
        mean([simAreaMaxY, simAreaMinY]), ...
        floor((simAreaMaxY-simAreaMinY)./gridResolution), gridResolution);
    [simAreaXs, simAreaYs] = meshgrid(simAreaXLabels,simAreaYLabels);
    
    % Discard map grid points out of the area of interest.
    boolsGridPtsToKeep = inpolygon(simAreaXs(:), simAreaYs(:), ...
        simGrid.xYRangePolyshape.Vertices(:,1), ...
        simGrid.xYRangePolyshape.Vertices(:,2));
    
    simGrid.utmXYs = [simAreaXs(boolsGridPtsToKeep), ...
        simAreaYs(boolsGridPtsToKeep)];
    
    simGridXs = simGrid.utmXYs(:,1);
    simGridYs = simGrid.utmXYs(:,2);
    
    simGridNumOfPts = length(simGridXs);
    simGridZones = repmat(simGrid.utmZone, simGridNumOfPts, 1);
    [simGridLats, simGridLons] ...
        = utm2deg(simGridXs, simGridYs, simGridZones);
    simGrid.latLons = [simGridLats, simGridLons];
    
    % Use USGS 1/3 arc-second (~10m) resolution data for US terrain
    % elevation.
    latRange = [min(simGridLats), max(simGridLats)];
    lonRange = [min(simGridLons), max(simGridLons)];
    region = fetchregion(latRange, lonRange, 'display', true);
    nistElevData = region.readelevation(latRange, lonRange, ...
        'sampleFactor', 1, 'display', true);
    % Interperlate nistElevData to get lidarAlts.
    [nistElevDataLons, nistElevDataLats] = meshgrid( ...
        nistElevData.longs, nistElevData.lats);
    simGrid.eles = interp2( ...
        nistElevDataLons, nistElevDataLats, ...
        nistElevData.elev, ...
        simGridLons, simGridLats);
    
    % Fill USGS elevations in the spots with NaN elevation values.
    boolsNanEle = isnan(simGrid.eles);
    if any(boolsNanEle)
        simGrid.eles(boolsNanEle) = queryElevationPointsFromUsgs( ...
            simGridLats(boolsNanEle), simGridLons(boolsNanEle), 'matlab');
    end
    assert(all(~isnan(simGrid.eles)), ...
        'There are NaN elevation values for the grid points!');
    save(pathToSaveGrid, 'simGrid');
end

% Plot.
hFigAreaOfInterest = figure('visible', ~flagGenFigSilently); hold on;
hAreaOfInterest = plot( ...
    simGrid.xYRangePolyshape, ...
    'FaceColor', areaOfInterestColor);
hGridPts = plot(simGrid.utmXYs(:,1), ...
    simGrid.utmXYs(:,2), '.b', 'MarkerSize', 3, 'Color', darkBlue);
axis equal; view(2); grid on;
legend([hAreaOfInterest, hGridPts], ...
    'Area of interest', 'RX location grid points', ...
    'Location', 'SouthEast');
transparentizeCurLegends;

curDirToSave = fullfile(ABS_PATH_TO_SAVE_PLOTS, 'Overview_RxLocGrid.png');
saveas(hFigAreaOfInterest, curDirToSave);

disp('    Done!')

%% Export Grid as a Simulation RX Track

disp(' ');
disp('    Exporting grid to .csv...');

gridTrackFileLabel = 'simGrid';

% For convenience.
if ~exist('simGridXs', 'var')
    simGridXs = simGrid.utmXYs(:,1);
    simGridYs = simGrid.utmXYs(:,2);
    simGridLats = simGrid.latLons(:,1);
    simGridLons = simGrid.latLons(:,2);
    simGridNumOfPts = length(simGridXs);
    simGridZones = repmat(simGrid.utmZone, simGridNumOfPts, 1);
end

% Function to fetch elevation according to the vegetation data structure.
if ~exist('getUsgsEleInMFromUtmXY', 'var')
    disp('        Generating getUsgsEleInMFromUtmXY...');
    getUsgsEleInMFromUtmXY = scatteredInterpolant( ...
        VEG_AREA_IMG_META.XS(:), ...
        VEG_AREA_IMG_META.YS(:), ...
        VEG_AREA_IMG_META.ALTS(:));
end
TX_ALT_USGS = getUsgsEleInMFromUtmXY(xTx, yTx);

% RX grid points.
fullPathRxLocs = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_track_', gridTrackFileLabel, '.csv']);

curAltsUsgsRx = getUsgsEleInMFromUtmXY(simGridXs, simGridYs);
% Fill USGS elevations in the spots with NaN elevation values.
boolsNanEle = isnan(curAltsUsgsRx);
if any(boolsNanEle)
    curAltsUsgsRx(boolsNanEle) = queryElevationPointsFromUsgs( ...
        simGridLats(boolsNanEle), simGridLons(boolsNanEle), 'matlab');
end
assert(all(~isnan(curAltsUsgsRx)), ...
    'There are NaN USGS elevation values for the grid points!');

curRxGroundHeightWrtTx ...
    = curAltsUsgsRx-(TX_ALT_USGS+TX_HEIGHT_M);

if exist(fullPathRxLocs, 'file')
    disp('        Skipping track csv file generation for the grid!');
else
    curHeaderCell = {'utmX', 'utmY', 'utmZone', ...
        'lat', 'lon', 'altFromUsgs', 'rxHeightWrtTXInM'};
    
    curRxHeightWrtTxInM = (RX_HEIGHT_M+curAltsUsgsRx)...
        -(TX_ALT_USGS+TX_HEIGHT_M);
    
    curData = [num2cell([simGridXs, ...
        simGridYs]), ...
        cellstr(simGridZones), ...
        ...
        num2cell([simGridLats, simGridLons, ...
        curAltsUsgsRx, ...
        curRxHeightWrtTxInM])];
    writeToCsvWithHeader(fullPathRxLocs, curHeaderCell, ...
        curData, dataStrFormatter);
end

% Measurement results. For fields that we do no have data, we need to pad
% NaNs.
fullPathRxMeas = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_meas_', gridTrackFileLabel, '.csv']);
if exist(fullPathRxMeas, 'file')
    disp('        Skipping meas csv file generation for the grid!');
else
    curHeaderCell = {'locIdx', 'pathLossInDb', 'rxToTx3DDistInM', ...
        'txAzimuth (clockwise from positive y)', ...
        'txElevation ("+" for upward)', ...
        'rxAzimuth (clockwise from positive y)', ...
        'rxElevation ("+" for upward)'};
    
    curRxToTx3DDistInM = vecnorm([simGridXs - xTx, ...
        simGridYs - yTx, curRxHeightWrtTxInM], 2, 2);
    
    nanPaddings = nan(simGridNumOfPts, 1);
    onesWithNumOfCurMeas = ones(simGridNumOfPts, 1);
    
    curData = [(1:simGridNumOfPts)', nanPaddings, curRxToTx3DDistInM, ...
        nanPaddings, ...
        nanPaddings, ...
        nanPaddings, ...
        nanPaddings];
    writeToCsvWithHeader(fullPathRxMeas, curHeaderCell, ...
        curData, dataStrFormatter);
end

disp('    Done!');

%% Figures According to the Exported .csv Files

disp(' ');
disp('    Generate figures according to exported .csv files...');

% rxLoc_track_#.csv
rxLocExp = readtable(fullPathRxLocs);
rxUtmXYsExp = [rxLocExp.utmX, rxLocExp.utmY];
rxLonLatExp = [rxLocExp.lon, rxLocExp.lat];
rxHeightWrtTxExp = rxLocExp.rxHeightWrtTXInM;

% TX GPS location.
[latTx, lonTx] = utm2deg(xTx, yTx, txUtmZone);

% Overview figure on a map.
curFigTitle = {'Simulation Grid Overview'; ...
    'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewLonLatHByCsv.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;
hTx = plot(lonTx, latTx, 'gx');
hRx = plot(rxLonLatExp(:,1), rxLonLatExp(:,2), ...
    'r.', 'MarkerSize', 5);
hLidar = plot(lonsVegAreaPolygon, latsVegAreaPolygon, ...
    '-w', 'LineWidth', 3);
plot_google_map('MapType', 'satellite');
xlabel('Longtitude'); ylabel('Latitude');
legend([hTx, hRx, hLidar], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');
transparentizeCurLegends;

title(curFigTitle)
saveas(curFig, curFigPath);

% LiDAR data.
downSampleRate = 30;
fctDownSample = @(x) x(1:downSampleRate:end, 1:downSampleRate:end);
vegXsLessExp = fctDownSample(VEG_AREA_IMG_META.XS);
vegYsLessExp = fctDownSample(VEG_AREA_IMG_META.YS);
vegZsWrtTxLessExp = fctDownSample( ...
    VEG_AREA_IMG_META.ZS-TX_ALT_USGS-TX_HEIGHT_M);

[xsVegAreaPolygon, ysVegAreaPolygon] ...
    = deg2utm(latsVegAreaPolygon, lonsVegAreaPolygon);

% Overview figure in UTM.
curFigTitle = {'Simulation Grid Overview in 3D'; ...
    'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewUtmXYHByCsv.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;

hLidar = plot3k([vegXsLessExp(:), vegYsLessExp(:), ...
    vegZsWrtTxLessExp(:)], 'Marker', {'.', 3}, 'ColorBar', false);

plot3([xTx xTx],[yTx yTx],[-TX_HEIGHT_M 0], 'g-');
hTx = plot3(xTx, yTx, 0, 'gx', 'LineWidth', 3, 'MarkerSize', 8);

plot3([rxUtmXYsExp(:,1) ...
    rxUtmXYsExp(:,1)]', ...
    [rxUtmXYsExp(:,2) ...
    rxUtmXYsExp(:,2)]', ...
    [rxHeightWrtTxExp curRxGroundHeightWrtTx]', ...
    'r-');
hRx = plot3(rxUtmXYsExp(:,1), rxUtmXYsExp(:,2), rxHeightWrtTxExp, ...
    'r.', 'MarkerSize', 5);

hLidarArea = plot(xsVegAreaPolygon, ysVegAreaPolygon, ...
    '-k', 'LineWidth', 3);

grid on; axis tight; axis equal; view(3);
xlabel('utmX'); ylabel('utmY'); ylabel('Height');
legend([hTx, hRx, hLidarArea], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');

title(curFigTitle)
saveas(curFig, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Generate Figures for Orignal Measurements
FLAG_GEN_FIGS_SILENTLY = flagGenFigSilently;

numOfTracks = length(contiPathLossesWithGpsInfo);
boolsToKeepMeas = cell(numOfTracks,1);
for idxTrack = 1:numOfTracks
    curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
    boolsToKeepMeas{idxTrack} = true(length(curLats),1);
end

curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simVsMeas'); %#ok<*NASGU>
flagGenFigsForAttennaBeam = true;
genEvalPerfFigsForMeas;
flagGenFigsForAttennaBeam = false;

%% Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary.
if false
    numOfTracks = length(contiPathLossesWithGpsInfo);
    boolsToKeepMeas = cell(numOfTracks,1);
    for idxTrack = 1:numOfTracks
        curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
        curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
        boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
            fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
            fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
    end
    
    curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
        'simVsMeasLess');
    genEvalPerfFigsForMeas;
end

%% Further Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary. Furthermore, we will discard track 6.
if false
    numOfTracks = length(contiPathLossesWithGpsInfo);
    boolsToKeepMeas = cell(numOfTracks,1);
    for idxTrack = 1:numOfTracks
        curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
        curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
        if idxTrack == 6
            boolsToKeepMeas{idxTrack} = false(length(curLons), 1);
        else
            boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
                fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
                fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
        end
    end
    
    curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
        'simVsMeasLessNoTrackSix');
    genEvalPerfFigsForMeas;
end

%% Furthest Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary. Furthermore, we will discard all traverse tracks, the
% segments with too much GPS errors, and results over the maximum
% measurable path loss.
if false
    MAX_MEASURABLE_PATH_LOSS_IN_DB = 182;
    numOfTracks = length(contiPathLossesWithGpsInfo);
    boolsToKeepMeas = cell(numOfTracks,1);
    for idxTrack = 1:numOfTracks
        curPathLosses = contiPathLossesWithGpsInfo{idxTrack}(:, 1);
        curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
        curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
        if idxTrack >= 6
            boolsToKeepMeas{idxTrack} = false(length(curLons), 1);
        else
            boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
                fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
                fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
            if idxTrack == 1
                indicesToDiscardOnTrackFive = 34:40;
                boolsToKeepMeas{idxTrack}(indicesToDiscardOnTrackFive) ...
                    = false(length(indicesToDiscardOnTrackFive), 1);
            elseif idxTrack == 2
                indicesToDiscardOnTrackFive = 132:152;
                boolsToKeepMeas{idxTrack}(indicesToDiscardOnTrackFive) ...
                    = false(length(indicesToDiscardOnTrackFive), 1);
            elseif idxTrack == 5
                indicesToDiscardOnTrackFive = 42:58;
                boolsToKeepMeas{idxTrack}(indicesToDiscardOnTrackFive) ...
                    = false(length(indicesToDiscardOnTrackFive), 1);
            end
            
            indicesTooBigPathLoss = find( ...
                curPathLosses>MAX_MEASURABLE_PATH_LOSS_IN_DB);
            boolsToKeepMeas{idxTrack}(indicesTooBigPathLoss) ...
                = false(length(indicesTooBigPathLoss), 1);
        end
    end
    
    curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
        'simVsMeasLessNoTraverseTracks');
    genEvalPerfFigsForMeas;
end

%% Prepare Results for Cleaned Measurements

tx3D = [xTx, yTx, ...
    queryElevationPointsFromUsgs(latTx, lonTx, 'matlab')+TX_HEIGHT_M];
srcGpsPt3D = [latTx, lonTx, tx3D(3)];

% Evaluate the foliage area and distance in woodland for all the measured
% locations.
if exist(pathToSavePredictionsForGrid, 'file')
    disp('    Loading history results...');
    load(pathToSavePredictionsForGrid);
else
    allContiPathLossesWithGpsInfo = vertcat(contiPathLossesWithGpsInfo{:});
    [numOfMeasPts, ~] = size(allContiPathLossesWithGpsInfo);
    allMeasNumsOfFoliagePixelsInFirstFresnel = deal(nan(numOfMeasPts, 1));
    allMeasUtmXYs = nan(numOfMeasPts, 2);
    
    disp(' ');
    disp('            Foliage area computation for all measurements...');
    
    allMeasLats = allContiPathLossesWithGpsInfo(:, 2);
    allMeasLons = allContiPathLossesWithGpsInfo(:, 3);
    [allMeasXs, allMeasYs, ~] = deg2utm(allMeasLats, allMeasLons);
    allMeasUtmXYs = [allMeasXs, allMeasYs];
    
    allMeasEles = getUsgsEleInMFromUtmXY(allMeasXs, allMeasYs);
    assert(all(~isnan(allMeasEles)), ...
        'NaN elevation value(s) found in measurement dataset!');
    
    ratioToReportProgress = 0.05;
    numOfMeasToReportProgress = ceil(numOfMeasPts.*ratioToReportProgress);
    parfor idxMeasPt = 1:numOfMeasPts
        curMeasLat = allMeasLats(idxMeasPt);
        curMeasLon = allMeasLons(idxMeasPt);
        curMeasEle = allMeasEles(idxMeasPt);
        
        dstGpsPt3D = [curMeasLat, curMeasLon, curMeasEle+RX_HEIGHT_M];
        
        [allMeasNumsOfFoliagePixelsInFirstFresnel(idxMeasPt), ~, ~]...
            = countNumOfFoliagePixelsInFirstFresnelZone(...
            srcGpsPt3D, dstGpsPt3D, ...
            vegAreas, VEG_AREA_IMG_META, F_C_IN_GHZ);
        if mod(idxMeasPt, numOfMeasToReportProgress)==1
            disp(['                Progress: ', ...
                num2str(idxMeasPt./numOfMeasPts.*100, '%.2f'), ...
                '% (pt #', num2str(idxMeasPt), ...
                '/', num2str(numOfMeasPts), ')']);
        end
    end
    
    measPredResults.allContiPathLossesWithGpsInfo ...
        = allContiPathLossesWithGpsInfo;
    measPredResults.utmXYs = allMeasUtmXYs;
    measPredResults.eles = allMeasEles;
    measPredResults.foliageAreasInFirstFresnel ...
        = allMeasNumsOfFoliagePixelsInFirstFresnel ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(1) ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(2);
    
    % FSPL for the measured locations.
    disp(' ');
    disp('            FSPL computation for the measurements...');
    [measPredResults.fsplInDb, ...
        measPredResults.distsToTxInM3d] ...
        = computeFreeSpacePathLosses(tx3D, ...
        [measPredResults.utmXYs, ...
        measPredResults.eles+RX_HEIGHT_M], F_C_IN_GHZ);
    disp('                Done!');
    
    disp(' ');
    disp('            Saving results for the cleaned measurements...');
    cleanedMeasPredResults.allContiPathLossesWithGpsInfo ...
        = measPredResults ...
        .allContiPathLossesWithGpsInfo(allBoolsToKeepMeas, :);
    cleanedMeasPredResults.utmXYs ...
        = measPredResults.utmXYs(allBoolsToKeepMeas, :);
    cleanedMeasPredResults.eles ...
        = measPredResults.eles(allBoolsToKeepMeas);
    cleanedMeasPredResults.foliageAreasInFirstFresnel ...
        = measPredResults.foliageAreasInFirstFresnel(allBoolsToKeepMeas);
    cleanedMeasPredResults.fsplInDb ...
        = measPredResults.fsplInDb(allBoolsToKeepMeas);
    cleanedMeasPredResults.distsToTxInM3d ...
        = measPredResults.distsToTxInM3d(allBoolsToKeepMeas);
    
    disp('                Done!');
end

%% Predictions for Extended RX Location Grid
% We will consider site-specific model C and the ITU model.

disp(' ');

if exist(pathToSavePredictionsForGrid, 'file')
    disp('    Loading history results...');
    load(pathToSavePredictionsForGrid);
else
    disp('    Generating predictions for extended RX locations...');
    
    disp('        FSPL...');
    % Free space loss values for all the points in the extended RX location
    % grid.
    [simGridPredResults.fsplInDb, simGridPredResults.distsToTxInM3d] ...
        = computeFreeSpacePathLosses(tx3D, ...
        [simGrid.utmXYs, simGrid.eles+RX_HEIGHT_M], F_C_IN_GHZ);
    
    disp('        Site-specific model C...');
    % Site-specific model C.
    historyModelResult ...
        = load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, ...
        'modelTwoStepLinearLossWrtFA');
    simGridPredResults.modelTwoStepLinearLossWrtFA ...
        = historyModelResult.modelTwoStepLinearLossWrtFA;
    
    % Estimate foliage areas, considering the RX height over the ground.
    numOfGridPts = length(simGrid.eles);
    simGridNumsOfFoliagePixelsInFirstFresnel = nan(numOfGridPts, 1);
    disp('            Foliage area computation...');
    
    ratioToReportProgress = 0.05;
    numOfMeasToReportProgress = ceil(numOfMeasPts.*ratioToReportProgress);
    parfor idxGridPt = 1:numOfGridPts
        dstGpsPt3D = [simGrid.latLons(idxGridPt,:), ...
            simGrid.eles(idxGridPt)+RX_HEIGHT_M]; %#ok<PFBNS>
        [simGridNumsOfFoliagePixelsInFirstFresnel(idxGridPt), ~, ~]...
            = countNumOfFoliagePixelsInFirstFresnelZone(...
            srcGpsPt3D, dstGpsPt3D, ...
            vegAreas, VEG_AREA_IMG_META, F_C_IN_GHZ);
        if mod(idxGridPt, numOfMeasToReportProgress)==1
            disp(['                Progress: ', ...
                num2str(idxGridPt./numOfGridPts.*100, '%.2f'), ...
                '% (pt #', num2str(idxGridPt), ...
                '/', num2str(numOfGridPts), ')']);
        end
    end
    
    disp('                Done!');
    simGridPredResults.foliageAreasInFirstFresnel ...
        = simGridNumsOfFoliagePixelsInFirstFresnel ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(1) ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(2);
    
    simGridPredResults.siteSpecificModelCPredictionsInDbOld ...
        = simGridPredResults.fsplInDb ...
        + simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        simGridPredResults.foliageAreasInFirstFresnel, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    measPredResults.siteSpecificModelCPredictionsInDbOld ...
        = measPredResults.fsplInDb ...
        + simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        measPredResults.foliageAreasInFirstFresnel, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbOld ...
        = cleanedMeasPredResults.fsplInDb ...
        + simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    disp('        ITU...');
    % ITU.
    historyModelResult = load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, ...
        'modelItuObsByWoodland');
    simGridPredResults.modelItuObsByWoodland ...
        = historyModelResult.modelItuObsByWoodland;
    
    % The clearance zone needed for the ITU model to compute the
    % in-woodland distance.
    firstVertex = [39.9914866126997, -105.274771171001];
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        = [ firstVertex; ...
        ...
        39.9913983555729, -105.274683363792; ...
        39.99124280167, -105.27456460806; ...
        39.9912124631283, -105.274460246949; ...
        39.9911694375684, -105.274395471159; ...
        39.9910425673101, -105.274183150317; ...
        39.9918227291569, -105.274511732652; ...
        39.9917942146102, -105.274643656646; ...
        39.9916127585283, -105.274649294408; ...
        39.9918832145105, -105.274199963594; ...
        39.9919402435825, -105.274356693825; ...
        39.9917047826908, -105.27391130951; ...
        39.9918097680052, -105.273976707698; ...
        39.9916887972767, -105.273839709727; ...
        39.9916093022227, -105.273700456614; ...
        39.9913785927558, -105.273739921031; ...
        39.9912403393027, -105.27389721502; ...
        39.99131983505, -105.274652677151; ...
        39.9917316722478, -105.273962967618; ...
        ...
        firstVertex];
    [clearanceZoneBoundXs, clearanceZoneBoundYs] = deg2utm( ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2));
    [~, ~, clearanceZoneBoundNewOrderIndices] ...
        = orderPolygonVertices( ...
        clearanceZoneBoundXs, clearanceZoneBoundYs);
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        = simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        (clearanceZoneBoundNewOrderIndices, :);
    clearanceZoneBoundXs = clearanceZoneBoundXs ...
        (clearanceZoneBoundNewOrderIndices, :);
    clearanceZoneBoundYs = clearanceZoneBoundYs ...
        (clearanceZoneBoundNewOrderIndices, :);
    
    % Compute distance in woodland for the grid.
    disp(' ');
    disp('            Woodland distances for the grid...');
    numOfGridPts = length(simGrid.eles);
    estiDistsNotInWoodland = nan(numOfGridPts, 1);
    for idxGridPt = 1:numOfGridPts
        curGridPtX = simGrid.utmXYs(idxGridPt, 1);
        curGridPtY = simGrid.utmXYs(idxGridPt, 2);
        curLineTxToRxXs = [curGridPtX, xTx];
        curLineTxToRxYs = [curGridPtY, yTx];
        [interXs, interYs] = polyxpoly( ...
            curLineTxToRxXs, curLineTxToRxYs, ...
            clearanceZoneBoundXs, clearanceZoneBoundYs);
        estiDistsNotInWoodland(idxGridPt) ...
            = norm([interXs-xTx, interYs-yTx]);
    end
    simGridPredResults.estiDistsInWoodland ...
        = simGridPredResults.distsToTxInM3d-estiDistsNotInWoodland;
    boolsGridPtsOutofWood = inpolygon(simGridLons, simGridLats, ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
    simGridPredResults.estiDistsInWoodland(boolsGridPtsOutofWood) = 0;
    disp('                Done!');
    
    simGridPredResults.ituPredictionsInDbOld = ...
        simGridPredResults.fsplInDb ...
        + simGridPredResults.modelItuObsByWoodland.excessLossFormula( ...
        simGridPredResults.estiDistsInWoodland, ...
        simGridPredResults.modelItuObsByWoodland.gammaRecommended, ...
        simGridPredResults.modelItuObsByWoodland.AmFitted);
    
    % Compute distance in woodland for measurements.
    disp(' ');
    disp('            Woodland distances for the measurements...');
    numOfMeasPts = length(allBoolsToKeepMeas);
    estiDistsNotInWoodland = nan(numOfMeasPts, 1);
    for idxMeasPt = 1:numOfMeasPts
        curGridPtX = measPredResults.utmXYs(idxMeasPt, 1);
        curGridPtY = measPredResults.utmXYs(idxMeasPt, 2);
        curLineTxToRxXs = [curGridPtX, xTx];
        curLineTxToRxYs = [curGridPtY, yTx];
        [interXs, interYs] = polyxpoly( ...
            curLineTxToRxXs, curLineTxToRxYs, ...
            clearanceZoneBoundXs, clearanceZoneBoundYs);
        estiDistsNotInWoodland(idxMeasPt) ...
            = norm([interXs-xTx, interYs-yTx]);
    end
    measPredResults.estiDistsInWoodland ...
        = measPredResults.distsToTxInM3d-estiDistsNotInWoodland;
    allContiPathLossesWithGpsInfo = vertcat(contiPathLossesWithGpsInfo{:});
    boolsMeasPtsOutOfWood = inpolygon( ...
        allContiPathLossesWithGpsInfo(:, 3), ...
        allContiPathLossesWithGpsInfo(:, 2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
    measPredResults.estiDistsInWoodland ...
        (boolsMeasPtsOutOfWood) = 0;
    
    cleanedMeasPredResults.estiDistsInWoodland ...
        = measPredResults.estiDistsInWoodland (allBoolsToKeepMeas);
    
    disp('                Done!');
    
    measPredResults.ituPredictionsInDbOld = ...
        measPredResults.fsplInDb ...
        + simGridPredResults.modelItuObsByWoodland.excessLossFormula( ...
        measPredResults.estiDistsInWoodland, ...
        simGridPredResults.modelItuObsByWoodland.gammaRecommended, ...
        simGridPredResults.modelItuObsByWoodland.AmFitted);
    
    cleanedMeasPredResults.ituPredictionsInDbOld = ...
        cleanedMeasPredResults.fsplInDb ...
        + simGridPredResults.modelItuObsByWoodland.excessLossFormula( ...
        cleanedMeasPredResults.estiDistsInWoodland, ...
        simGridPredResults.modelItuObsByWoodland.gammaRecommended, ...
        simGridPredResults.modelItuObsByWoodland.AmFitted);
    
    disp(' ');
    disp('            Refitting site-specific model C...');
    % For two-step linear model for foliage area.
    allContiPathLossesWithGpsInfoCleaned ...
        = allContiPathLossesWithGpsInfo(allBoolsToKeepMeas, :);
    
    modelTwoStepLinearLossWrtFA ...
        = simGridPredResults.modelTwoStepLinearLossWrtFA;
    fctToFit = @(paraToFit, input) ...
        modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        input, paraToFit(1), paraToFit(2), paraToFit(3), paraToFit(4));
    startingPtTwoStepLinearWrtFA ...
        = [modelTwoStepLinearLossWrtFA.constPerUoFACloseFitted, ...
        modelTwoStepLinearLossWrtFA.constPerUoFAFarFitted, ...
        modelTwoStepLinearLossWrtFA.boundaryFitted, ...
        modelTwoStepLinearLossWrtFA.constShiftFitted];
    fittedRes = nlinfit( ...
        cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
        allContiPathLossesWithGpsInfoCleaned(:, 1) ...
        -cleanedMeasPredResults.fsplInDb, ...
        fctToFit, startingPtTwoStepLinearWrtFA);
    modelTwoStepLinearLossWrtFA.constPerUoFACloseFitted = fittedRes(1);
    modelTwoStepLinearLossWrtFA.constPerUoFAFarFitted = fittedRes(2);
    modelTwoStepLinearLossWrtFA.boundaryFitted = fittedRes(3);
    modelTwoStepLinearLossWrtFA.constShiftFitted = fittedRes(4);
    
    % Store the results.
    cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        = modelTwoStepLinearLossWrtFA;
    disp('                Done!');
    
    % For the ITU model, refit Am to our data.
    disp(' ');
    disp('            Refitting ITU...');
    modelItuObsByWoodland = simGridPredResults.modelItuObsByWoodland;
    fctToFit = @(amToFit, d) modelItuObsByWoodland.excessLossFormula( ...
        d, modelItuObsByWoodland.gammaRecommended, amToFit);
    modelItuObsByWoodland.AmFitted = nlinfit( ...
        cleanedMeasPredResults.estiDistsInWoodland, ...
        allContiPathLossesWithGpsInfoCleaned(:, 1) ...
        - cleanedMeasPredResults.fsplInDb, ...
        fctToFit, rand(1));
    
    % Store the results.
    cleanedMeasPredResults.modelItuObsByWoodland ...
        = modelItuObsByWoodland;
    disp('                Done!');
    
    % RMSDs compared with the simulation results.
    %     rmsdTwoStepLinearLossWrtFA = sqrt(mean( ...
    %      (allPredictedPathLossesTwoStepLinearLossWrtFA ...
    %     - allMeasPathLosses).^2));
    
    simGridPredResults.siteSpecificModelCPredictionsInDbNew ...
        = simGridPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        simGridPredResults.foliageAreasInFirstFresnel, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    measPredResults.siteSpecificModelCPredictionsInDbNew ...
        = measPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        measPredResults.foliageAreasInFirstFresnel, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbNew ...
        = cleanedMeasPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    simGridPredResults.ituPredictionsInDbNew = ...
        simGridPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelItuObsByWoodland ...
        .excessLossFormula( ...
        simGridPredResults.estiDistsInWoodland, ...
        cleanedMeasPredResults.modelItuObsByWoodland.gammaRecommended, ...
        cleanedMeasPredResults.modelItuObsByWoodland.AmFitted);
    
    measPredResults.ituPredictionsInDbNew = ...
        measPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelItuObsByWoodland ...
        .excessLossFormula( ...
        measPredResults.estiDistsInWoodland, ...
        cleanedMeasPredResults.modelItuObsByWoodland.gammaRecommended, ...
        cleanedMeasPredResults.modelItuObsByWoodland.AmFitted);
    
    cleanedMeasPredResults.ituPredictionsInDbNew = ...
        cleanedMeasPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelItuObsByWoodland ...
        .excessLossFormula( ...
        cleanedMeasPredResults.estiDistsInWoodland, ...
        cleanedMeasPredResults.modelItuObsByWoodland.gammaRecommended, ...
        cleanedMeasPredResults.modelItuObsByWoodland.AmFitted);
    
    save(pathToSavePredictionsForGrid, ...
        'measPredResults', 'cleanedMeasPredResults', 'simGridPredResults');
end

% Overview for the clearance zone around the TX.
allPLValues = [simGridPredResults.fsplInDb; ...
    simGridPredResults.ituPredictionsInDbOld; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
plRange = [floor(min(allPLValues)./10) ceil(max(allPLValues)./10)].*10;

hFigOverviewForClearanceZone = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, simGridPredResults.fsplInDb], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'FSPL (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ = max(simGridPredResults.fsplInDb)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
hClearanceZone = fill3( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
    ones(length( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1) ...
    )).*higherLayerZ, 'w');
alpha(hClearanceZone, 0.5); axis tight;
view(2);
legend([hTx, hTrees(1), hClearanceZone(1)], ...
    'TX', 'Trees', 'Clear zone', ...
    'Location', 'southeast');
plot_google_map('MapType', 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForClearanceZone.png');
saveas(hFigOverviewForClearanceZone, curFigPath);

% Overview of the results from ITU.
hFigOverviewForItu = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbOld], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old ITU (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ = max(simGridPredResults.ituPredictionsInDbOld)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
hClearanceZone = fill3( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
    ones(length( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1) ...
    )).*higherLayerZ, 'w');
alpha(hClearanceZone, 0.5); axis tight;
view(2);
legend([hTx, hTrees(1), hClearanceZone(1)], ...
    'TX', 'Trees', 'Clear zone', ...
    'Location', 'southeast');
% plot_google_map('MapType', 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForItu.png');
saveas(hFigOverviewForItu, curFigPath);

% Overview of the results from site-specific model C.
hFigOverviewForSiteSpecificC = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old SS-C (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simGridPredResults.siteSpecificModelCPredictionsInDbOld)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSiteSpecificC, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSiteSpecificC.png');
saveas(hFigOverviewForSiteSpecificC, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Model Prediction Comparisons

disp(' ');
disp('    Comparisons with the simulation results for the big grid...');

if strcmpi(simGridLossCalibMethod, 'fspl')
    INITIAL_MULTIPLICATION_FACTOR = 30;
else
    INITIAL_MULTIPLICATION_FACTOR = 1;
end

% The simulation results for the extended RX location grid.
simPLsForGridOrig ...
    = loadSimLossFromExcel(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID, ...
    INITIAL_MULTIPLICATION_FACTOR);
% simResultsForGridTable = readtable(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
%  simPLsForGridOrig = simResultsForGridTable.simLoss_dB_;

[~, curSimResultsForGridFilename] ...
    = fileparts(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
if strcmpi(curSimResultsForGridFilename, ...
        'var_grnd_grid_propagation_stats_20191026')
    simPLsForGrid = nan(5742, 1);
    simPLsForGridIndices = simResultsForGridTable.id;
    simPLsForGrid(simPLsForGridIndices) = simPLsForGridOrig;
else
    simPLsForGrid = simPLsForGridOrig;
end


[~, gridRawDataFilename, ~] ...
    = fileparts(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
if strcmp(gridRawDataFilename, 'var_grnd_grid_propagation_stats_20191026' )
    % For now, the const values of ~263 shown in simPLsForGrid are not
    % valide.
    simPLsForGrid(simPLsForGrid==simPLsForGrid(1)) = nan;
end

% Calibrate the simulation results for the grid.
switch lower(simGridLossCalibMethod)
    case 'fspl'
        % Fit simulation results to FSPL at 1 m reference point. First,
        % find the index for the LoS 1-m close-in reference point.
        CLOSE_IN_REF_POINT_DIST_IN_M = 1;
        
        boolsGridPtsOutofWood = inpolygon(simGridLons, simGridLats, ...
            simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2),...
            simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
        distsToTxInM3dOutOfWood = simGridPredResults.distsToTxInM3d;
        distsToTxInM3dOutOfWood(~boolsGridPtsOutofWood) = inf;
        
        [curMinDistDiff, idxForCloseInRefGridPt] = min(abs( ...
            simGridPredResults.distsToTxInM3d ...
            - CLOSE_IN_REF_POINT_DIST_IN_M));
        
        [xCloseInRefGridPt, yCloseInRefGridPt] = deg2utm( ...
            simGridLats(idxForCloseInRefGridPt), ...
            simGridLons(idxForCloseInRefGridPt));
        distTxToCloseInRefGridPt = norm([xTx, yTx] ...
            - [xCloseInRefGridPt, yCloseInRefGridPt]);
        fsplCloseInRefGridPt ...
            = simGridPredResults.fsplInDb(idxForCloseInRefGridPt);
        simGridPlShiftAmount = fsplCloseInRefGridPt ...
            - simPLsForGrid(idxForCloseInRefGridPt);
        simPLsForGridCalibrated = simPLsForGrid + simGridPlShiftAmount;
    case 'cleanedmeas'
        simLossForMeas = cell(numOfTracks,1);
        for idxTrack = 1:numOfTracks
            curDirToLoadSimResults ...
                = dirsToLoadSimResultsForEachTrack{idxTrack};
            if ~isempty(curDirToLoadSimResults)
                simLossForMeas{idxTrack} ...
                    = loadSimLossFromExcel(curDirToLoadSimResults, ...
                    INITIAL_MULTIPLICATION_FACTOR);
                
                assert(all(~isnan(simLossForMeas{idxTrack})), ...
                    'NaN value found in simulation results!');
            end
        end
        allSimPlForMeas = vertcat(simLossForMeas{:});
        allSimPlForMeasCleaned = allSimPlForMeas(allBoolsToKeepMeas);
        
        allContiPathLossesWithGpsInfo ...
            = vertcat(contiPathLossesWithGpsInfo{:});
        allContiPathLossesWithGpsInfoCleaned ...
            = allContiPathLossesWithGpsInfo(allBoolsToKeepMeas, :);
        curMeasLosses = allContiPathLossesWithGpsInfoCleaned(:,1);
        expectedNumOfSamps = length(curMeasLosses);
        curSimLoss = allSimPlForMeasCleaned;
        
        % Load history TX to RX distance.
        rxToTx3DDistInM = cell(numOfTracks,1);
        for idxTrack = 1:numOfTracks
            curRxLocCsv = readtable(fullfile(ABS_PATH_TO_SIM_CSV_FILES, ...
                ['rxLoc_meas_', num2str(idxTrack), '.csv']));
            rxToTx3DDistInM{idxTrack} ...
                = curRxLocCsv.rxToTx3DDistInM(boolsToKeepMeas{idxTrack});
        end
        curRxToTx3DDistInM = vertcat(rxToTx3DDistInM{:});
        [curSortedRxToTxDists, indicesSortByDist] ...
            = sort(curRxToTx3DDistInM);
        
        [curCalibratedSim, curBestShift, curMultiFactor] ...
            = calibrateSimPlsWithMeas(curSimLoss(indicesSortByDist), ...
            curMeasLosses(indicesSortByDist));
        
        % Plot RMSD vs shift around the best shift value.
        curFigFilenamePrefix = 'SimVsMeas_MeasCleaned';
        
        % Plot simulation results with measurements.
        hFigSimVsMeasByIdx = figure('visible', ~flagGenFigSilently);
        hold on;
        hSim = plot(1:expectedNumOfSamps, curCalibratedSim, 'x');
        hMeas = plot(1:expectedNumOfSamps, curMeasLosses, '.');
        xlabel('Sample'); ylabel('RMSD (dB)');
        grid on; grid minor; axis tight;
        if ~isempty(hSim)
            legend([hSim, hMeas], 'Simulation', 'Measurement');
        end
        pathToSaveCurFig = fullfile(curAbsPathToSavePlots, ...
            [curFigFilenamePrefix, '_PlVsSampIdx_MeasCleaned', ...
            num2str(idxTrack), '.png']);
        
        saveas(hFigSimVsMeasByIdx, pathToSaveCurFig);
        
        % Another comparison figure with TX-to-RX distance as the x axis.
        hFigSimVsMeasByDist = figure('visible', ~flagGenFigSilently);
        hold on;
        if ~isempty(curSortedRxToTxDists)
            hSim = plot(curSortedRxToTxDists, ...
                curCalibratedSim(indicesSortByDist), 'x-');
            hMeas = plot(curSortedRxToTxDists, ...
                curMeasLosses(indicesSortByDist), '.--');
        end
        xlabel('3D RX-to-TX Distance (m)'); ylabel('RMSD (dB)');
        grid on; grid minor; axis tight;
        if ~isempty(hSim)
            legend([hSim, hMeas], 'Simulation', 'Measurement', ...
                'Location', 'SouthEast');
        end
        pathToSaveCurFig = fullfile(curAbsPathToSavePlots, ...
            [curFigFilenamePrefix, '_PlVsDist_MeasCleaned', ...
            num2str(idxTrack), '.png']);
        
        saveas(hFigSimVsMeasByDist, pathToSaveCurFig);
        
        simGridPlShiftAmount = curBestShift;
        simGridPlMultiFactor = curMultiFactor;
        simPLsForGridCalibrated = simPLsForGrid.*curMultiFactor ...
            + curBestShift;
    case 'trackoneongrid'
        [trackOnUtmXs, trackOnUtmY] = deg2utm( ...
            contiPathLossesWithGpsInfo{1}(:, 3), ...
            contiPathLossesWithGpsInfo{1}(:, 2));
        indicesGridPtsForTrackOne ...
            = knnsearch(simGrid.utmXYs, [trackOnUtmXs, trackOnUtmY]);
        
        curSimLoss = simPLsForGrid(indicesGridPtsForTrackOne);
        curMeasLosses = contiPathLossesWithGpsInfo{1}(:, 1);
        
        idxTrack = 1;
        % Load history TX to RX distance.
        curRxLocCsv = readtable(fullfile(ABS_PATH_TO_SIM_CSV_FILES, ...
            ['rxLoc_meas_', num2str(idxTrack), '.csv']));
        curRxToTx3DDistInM ...
            = curRxLocCsv.rxToTx3DDistInM(boolsToKeepMeas{idxTrack});
        
        curRxToTx3DDistInM ...
            = curRxLocCsv.rxToTx3DDistInM(boolsToKeepMeas{idxTrack});
        [~, indicesSortByDist] ...
            = sort(curRxToTx3DDistInM);
        
        [~, curBestShift, ...
            curMultiFactor] ...
            = calibrateSimPlsWithMeas(curSimLoss(indicesSortByDist), ...
            curMeasLosses(indicesSortByDist));
        
        simGridPlShiftAmount = curBestShift;
        simGridPlMultiFactor = curMultiFactor;
        simPLsForGridCalibrated = simPLsForGrid.*curMultiFactor ...
            + curBestShift;
    case 'cleanedmeasongrid'
        [simPLsForGridAsCali, indicesGridPtsForCurTrack] ....
            = deal(cell(numOfTracks, 1));
        for idxTrack = 1:numOfTracks
            [trackOnUtmXs, trackOnUtmY] = deg2utm( ...
                contiPathLossesWithGpsInfo{idxTrack}(:, 2), ...
                contiPathLossesWithGpsInfo{idxTrack}(:, 3));
            indicesGridPtsForCurTrack{idxTrack} ...
                = knnsearch(simGrid.utmXYs, [trackOnUtmXs, trackOnUtmY]);
            
            simPLsForGridAsCali{idxTrack} ...
                = simPLsForGrid(indicesGridPtsForCurTrack{idxTrack});
        end
        allSimPLsForGridAsCali = vertcat(simPLsForGridAsCali{:});
        
        allContiPathLossesWithGpsInfo ...
            = vertcat(contiPathLossesWithGpsInfo{:});
        [~, curBestShift, ...
            curMultiFactor] = calibrateSimPlsWithMeas( ...
            allSimPLsForGridAsCali, ...
            allContiPathLossesWithGpsInfo(:, 1));
        
        simGridPlShiftAmount = curBestShift;
        simGridPlMultiFactor = curMultiFactor;
        simPLsForGridCalibrated = simPLsForGrid.*curMultiFactor ...
            + curBestShift;
        
        % Generate comparison plots with the measurements for each track
        % according to the grid simulation results.
        [allSimLossesCleanedMeasOnGrid, allMeasLossesCleanedMeasOnGrid, ...
            allRxToTx3DDistInMCleanedMeasOnGrid] ...
            = deal(cell(numOfTracks,1));
        for idxTrack = 1:numOfTracks
            % Load history TX to RX distance.
            curRxLocCsv = readtable(fullfile(ABS_PATH_TO_SIM_CSV_FILES, ...
                ['rxLoc_meas_', num2str(idxTrack), '.csv']));
            curRxToTx3DDistInM ...
                = curRxLocCsv.rxToTx3DDistInM(boolsToKeepMeas{idxTrack});
            
            [curSortedRxToTxDists, indicesSortByDist] ...
                = sort(curRxToTx3DDistInM);
            
            curMeasPlsSorted = contiPathLossesWithGpsInfo{idxTrack}...
                (boolsToKeepMeas{idxTrack});
            curMeasPlsSorted = curMeasPlsSorted(indicesSortByDist);
            
            curSimPlsSorted = simPLsForGridCalibrated( ...
                indicesGridPtsForCurTrack{idxTrack});
            curSimPlsSorted = curSimPlsSorted(indicesSortByDist);
            
            curRmsd = sqrt(mean((curSimPlsSorted-curMeasPlsSorted).^2));
            
            allSimLossesCleanedMeasOnGrid{idxTrack} = curSimPlsSorted;
            allMeasLossesCleanedMeasOnGrid{idxTrack} = curMeasPlsSorted;
            allRxToTx3DDistInMCleanedMeasOnGrid{idxTrack} ...
                = curSortedRxToTxDists;
            
            % Path loss vs distance.
            hFigSimVsMeasByDist = figure('visible', ~flagGenFigSilently);
            hold on;
            hSim = plot(curSortedRxToTxDists, ...
                curSimPlsSorted, 'x-');
            hMeas = plot(curSortedRxToTxDists, ...
                curMeasPlsSorted, '.--');
            title(['RMSD = ', num2str(curRmsd, '%.2f'), ' dB']);
            xlabel('3D RX-to-TX Distance (m)'); ylabel('Path Loss (dB)');
            grid on; grid minor; axis tight;
            if ~isempty(hSim)
                legend([hSim, hMeas], 'Simulation', 'Measurement', ...
                    'Location', 'SouthEast');
            end
            pathToSaveCurFig = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
                ['GridSimResults_PlVsDist_Track_', ...
                num2str(idxTrack), '.png']);
            
            saveas(hFigSimVsMeasByDist, pathToSaveCurFig);
        end
        
        % An overview of the path loss vs distanace for all the tracks.
        curSimLosses = vertcat(allSimLossesCleanedMeasOnGrid{:});
        curMeasLosses = vertcat(allMeasLossesCleanedMeasOnGrid{:});
        curRxToTx3DDistInM ...
            = vertcat(allRxToTx3DDistInMCleanedMeasOnGrid{:});
        
        [sortedRxToTxDistsGrid, indicesSortByDist] ...
            = sort(curRxToTx3DDistInM);
        
        curCalibratedSim = curSimLosses(indicesSortByDist);
        curMeasLosses = curMeasLosses(indicesSortByDist);
        
        curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));
        
        % The path loss over distance plot for all data.
        hFigSimVsMeasByDist = figure('visible', ~flagGenFigSilently);
        hold on;
        hSim = plot(sortedRxToTxDistsGrid, ...
            curCalibratedSim, 'x-');
        hMeas = plot(sortedRxToTxDistsGrid, ...
            curMeasLosses, '.--');
        title(['Overall RMSD = ', num2str(curRmsd, '%.2f'), ' dB']);
        xlabel('3D RX-to-TX Distance (m)'); ylabel('Path Loss (dB)');
        grid on; grid minor; axis tight;
        if ~isempty(hSim)
            legend([hSim, hMeas], 'Simulation', 'Measurement', ...
                'Location', 'SouthEast');
        end
        pathToSaveCurFig = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
            'GridSimResults_PlVsDist_AllTracks.png');
        saveas(hFigSimVsMeasByDist, pathToSaveCurFig);
    otherwise
        error(['Unknown calibration method: ', simGridLossCalibMethod]);
end

% Overview of the simulation results.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simPLsForGridCalibrated], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Sim Results (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForGrid.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of FSPL.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.fsplInDb], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'FSPL (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForFspl.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the simulation results full range.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simPLsForGridCalibrated], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Sim Results (dB)'}, ...
    'ColorRange', [ceil(max(simPLsForGridCalibrated)), ...
    floor(min(simPLsForGridCalibrated))]);
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForGrid_FullRange.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference between the ITU predictions and the simulation
% results.
ituVsSimZsOld = simGridPredResults.ituPredictionsInDbOld ...
    - simPLsForGridCalibrated;
sscVsSimZsOld = simGridPredResults.siteSpecificModelCPredictionsInDbOld ...
    - simPLsForGridCalibrated;
ituVsSimZsNew = simGridPredResults.ituPredictionsInDbNew ...
    - simPLsForGridCalibrated;
sscVsSimZsNew = simGridPredResults.siteSpecificModelCPredictionsInDbNew ...
    - simPLsForGridCalibrated;
fspsVsSimZs = simGridPredResults.fsplInDb - simPLsForGridCalibrated;

% Shift the new ITU and site-specific C results to see what the best fit
% will look like.

% We will treat the simulation results as the ground truth and calibrate
% the model predictions to see the best poissible agreement that could be
% achieved. First, for the site-specific C model.
curMeasLosses = simPLsForGridCalibrated;
curSimLoss = simGridPredResults.siteSpecificModelCPredictionsInDbNew;

[simGridPredResults.siteSpecificModelCPredictionsInDbNewCalibrated, ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedShift, ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedMultiFactor] ...
    = calibrateSimPlsWithMeas(curSimLoss, curMeasLosses, 'both');

sscVsSimZsNewShifted ...
    = simGridPredResults.siteSpecificModelCPredictionsInDbNewCalibrated ...
    - simPLsForGridCalibrated;

% Now for the ITU model.
curMeasLosses = simPLsForGridCalibrated;
curSimLoss = simGridPredResults.ituPredictionsInDbNew;

[simGridPredResults.ituPredictionsInDbNewCalibrated, ...
    simGridPredResults.ituPredictionsInDbNewCalibratedShift, ...
    simGridPredResults.ituPredictionsInDbNewCalibratedMultiFactor] ...
    = calibrateSimPlsWithMeas(curSimLoss, curMeasLosses, 'both');

ituVsSimZsNewShifted ....
    = simGridPredResults.ituPredictionsInDbNewCalibrated ...
    - simPLsForGridCalibrated;

% For plotting in the same path loss range.
curPLDiffs = [ituVsSimZsOld; sscVsSimZsOld; ...
    ituVsSimZsNew; sscVsSimZsNew; fspsVsSimZs; ...
    sscVsSimZsNewShifted; ituVsSimZsNewShifted];

% curColorRange = [ceil(max(curPLDiffs)), floor(min(curPLDiffs))];
curColorRange = [0, ceil(max(abs(curPLDiffs)))];

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, ituVsSimZsOld], ...
    'Old ITU', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridOldItuVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference between the site-specific C predictions and
% the simulation results.
hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, sscVsSimZsOld], ...
    'Old SS-C', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridOldSiteSpecificCVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference for the new model fitting results.
hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, ituVsSimZsNew], ...
    'New ITU', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewItuVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, sscVsSimZsNew], ...
    'New SS-C', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewSiteSpecificCVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, simGridLats, fspsVsSimZs], ...
    'FSPL', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridFsplVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% For the calibrated (according to the model predictions) ones.
hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, ...
    simGridLats, ituVsSimZsNewShifted], ...
    'New ITU Shifted', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);
hTitleStr = get(get(gca, 'title'), 'string');
title({['shift = ', num2str( ...
    simGridPredResults ...
    .ituPredictionsInDbNewCalibratedShift), ...
    ' dB, multiFactor = ', num2str( ...
    simGridPredResults ...
    .ituPredictionsInDbNewCalibratedMultiFactor)]; ...,
    hTitleStr});
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewItuCalibratedVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigSimPLsCalibratedForGrid = figure('visible', ~flagGenFigSilently);
hold on;
hOldSim = plot(simGridPredResults.distsToTxInM3d, ...
    simPLsForGridCalibrated, 'r*');
hItuBySimCali = plot(simGridPredResults.distsToTxInM3d, ...
    simGridPredResults ...
    .ituPredictionsInDbNewCalibrated, 'go');
hItu = plot(simGridPredResults.distsToTxInM3d, simGridPredResults ...
    .ituPredictionsInDbNew, 'b.');
legend([hOldSim, hItuBySimCali, hItu], 'Sim', 'ITU Cali by Sim', 'ITU');
grid on; grid minor;
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewSiteSpecificCCalibratedVsSim_PlOverDist.png');
saveas(hFigSimPLsCalibratedForGrid, curFigPath);

hFigOverviewForSimPLsForGrid ...
    = plotPathLossDiff([simGridLons, ...
    simGridLats, sscVsSimZsNewShifted], ...
    'New SS-C Shifted', curColorRange, [lonTx, latTx], ...
    [markLocs(:,2), markLocs(:,1)], flagGenFigSilently);
hTitleStr = get(get(gca, 'title'), 'string');
title({['shift = ', num2str( ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedShift), ...
    ' dB, multiFactor = ', num2str( ...
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibratedMultiFactor)]; ...,
    hTitleStr});
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewSiteSpecificCCalibratedVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigSimPLsCalibratedForGrid= figure('visible', ~flagGenFigSilently);
hold on;
hOldSim = plot(simGridPredResults.distsToTxInM3d, ...
    simPLsForGridCalibrated, 'r*');
hSscCaliBySim = plot(simGridPredResults.distsToTxInM3d, ....
    simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNewCalibrated, 'go');
hSsc = plot(simGridPredResults.distsToTxInM3d, simGridPredResults ...
    .siteSpecificModelCPredictionsInDbNew, 'b.');
legend([hOldSim, hSscCaliBySim, hSsc], 'Sim', 'SS-C Cali by Sim', 'SS-C');
grid on; grid minor;
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewItuCalibratedVsSim_PlOverDist.png');
saveas(hFigSimPLsCalibratedForGrid, curFigPath);

% Plot diff vs TX-to-RX distance.
hFigDiffVsTxToRxDist = figure('visible', ~flagGenFigSilently);
hold on; alphaToSet = 1;
hFSPL = scatter(simGridPredResults.distsToTxInM3d, fspsVsSimZs, '*', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
hITU = scatter(simGridPredResults.distsToTxInM3d, ituVsSimZsOld, '^', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
hSSC = scatter(simGridPredResults.distsToTxInM3d, sscVsSimZsOld, '.', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
title('Difference between Model Predictions and Simulation Results');
legend([hFSPL, hITU, hSSC], 'FSPL', 'ITU', 'Site-Specific C');
grid on;

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'predictionSimDiffVsDistToTx.png');
saveas(hFigDiffVsTxToRxDist, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Extra Plots

disp('    Generating extra plots...');

% We will use surf for the path loss results.
simConfigs.UTM_X_Y_BOUNDARY_OF_INTEREST ...
    = simGrid.xYRangePolyshape.Vertices;
simConfigs.utm2deg_speZone = @(x, y) utm2deg(x, y, ...
    repmat(simGrid.utmZone, length(x),1));
simConfigs.deg2utm_speZone = @(lon, lat) deg2utm(lon, lat);
simConfigs.CURRENT_SIMULATION_TAG = 'NistForestGrid';
simConfigs.NUM_OF_PIXELS_FOR_LONGER_SIDE ...
    = simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE;
flagVisible = ~flagGenFigSilently;
txLonLats = [lonTx, latTx];
flagZoomIn = true;

allPathlossValues = [simGridPredResults.fsplInDb; ...
    simPLsForGridCalibrated; simGridPredResults.ituPredictionsInDbOld; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld; ...
    simGridPredResults.ituPredictionsInDbNew; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew];
simConfigs.ALLOWED_PATH_LOSS_RANGE_IN_DB ...
    = [floor(min(allPathlossValues)./10), ...
    ceil(max(allPathlossValues)./10)].*10;

% Overview of FSPL.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.fsplInDb];
colorbarTitle = 'FSPL (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSimPLsForFspl.png');
saveas(hCurPLMap, curFigPath);

% Overview of the simulation results.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simPLsForGridCalibrated];
colorbarTitle = 'Sim Results (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSimPLsForGrid.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from ITU.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbOld];
colorbarTitle = 'Old ITU (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForItu.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from site-specific model C.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
colorbarTitle = 'Old SS-C (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSiteSpecificC.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from ITU (new).
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbNew];
colorbarTitle = 'New ITU (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForItuNew.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from site-specific model C (new)..
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew];
colorbarTitle = 'New SS-C (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSiteSpecificCNew.png');
saveas(hCurPLMap, curFigPath);

% For site-specific C model on measurements: path loss vs foliage area.
hFigPlOverAf = figure('visible', ~flagGenFigSilently); hold on;
% All measurements.
hAllMeas = plot(measPredResults.foliageAreasInFirstFresnel, ...
    measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - measPredResults.fsplInDb, 'or');
% Cleaned measurements.
hCleanedMeas = plot(cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
    cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - cleanedMeasPredResults.fsplInDb, '*b');
% Old SSC.
hOldSsc = plot(measPredResults.foliageAreasInFirstFresnel, ...
    measPredResults.siteSpecificModelCPredictionsInDbOld ...
    - measPredResults.fsplInDb, '.k');
% New SSC.
hNewSsc = plot(cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbNew ...
    - cleanedMeasPredResults.fsplInDb, '.g');
axis tight; xlabel('Foliage Area (m^2)'); ylabel('Excess Path Loss (dB)');
grid on; grid minor;
legend([hAllMeas, hCleanedMeas, hOldSsc, hNewSsc], ...
    'All measurements', 'Cleaned measurements', 'Old SS-C', 'New SS-C', ...
    'Location', 'southeast');
rmseOld = sqrt(sum(( ...
    measPredResults.siteSpecificModelCPredictionsInDbOld ...
    - measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(measPredResults.ituPredictionsInDbOld));
rmseNew = sqrt(sum(( ...
    cleanedMeasPredResults.siteSpecificModelCPredictionsInDbNew ...
    - cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(cleanedMeasPredResults.ituPredictionsInDbOld));
title({['Old RMSE = ', num2str(rmseOld), ' dB']; ...
    ['New RMSE = ', num2str(rmseNew), ' dB']});

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'fittedModelSiteSpecificC.png');
saveas(hFigPlOverAf, curFigPath);

% For the ITU model on measurements: path loss vs woodland distance.
hFigPlOverDw = figure('visible', ~flagGenFigSilently); hold on;
% All measurements.
hAllMeas = plot(measPredResults.estiDistsInWoodland, ...
    measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - measPredResults.fsplInDb, 'or');
% Cleaned measurements.
hCleanedMeas = plot(cleanedMeasPredResults.estiDistsInWoodland, ...
    cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    - cleanedMeasPredResults.fsplInDb, '*b');
% Old ITU.
hOldSsc = plot(measPredResults.estiDistsInWoodland, ...
    measPredResults.ituPredictionsInDbOld ...
    - measPredResults.fsplInDb, '.k');
% New ITU.
hNewSsc = plot(cleanedMeasPredResults.estiDistsInWoodland, ...
    cleanedMeasPredResults.ituPredictionsInDbNew ...
    - cleanedMeasPredResults.fsplInDb, '.g');
axis tight; xlabel('Woodland Distance (m)');
ylabel('Excess Path Loss (dB)');
grid on; grid minor;
legend([hAllMeas, hCleanedMeas, hOldSsc, hNewSsc], ...
    'All measurements', 'Cleaned measurements', 'Old ITU', 'New ITU', ...
    'Location', 'southeast');
rmseOld = sqrt(sum(( ...
    measPredResults.ituPredictionsInDbOld ...
    - measPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(measPredResults.ituPredictionsInDbOld));
rmseNew = sqrt(sum(( ...
    cleanedMeasPredResults.ituPredictionsInDbNew ...
    - cleanedMeasPredResults.allContiPathLossesWithGpsInfo(:,1) ...
    ).^2)/length(cleanedMeasPredResults.ituPredictionsInDbOld));
title({['Old RMSE = ', num2str(rmseOld), ' dB']; ...
    ['New RMSE = ', num2str(rmseNew), ' dB']});

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'fittedModelItu.png');
saveas(hFigPlOverDw, curFigPath);

% For site-specific C model on grid: foliage area on map.
hFigAfOnMapForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap jet;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.foliageAreasInFirstFresnel], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Foliage Area (m^2)'});
higherLayerZ ...
    = max(simGridPredResults.foliageAreasInFirstFresnel)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
axis tight;
view(2);
legend(hTx, 'TX', 'Location', 'southeast');
plotGoogleMapAfterPlot3k(hFigAfOnMapForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'gridAfOnMap.png');
saveas(hFigAfOnMapForGrid, curFigPath);

% For ITU and site-specific C vs simulation results on the grid, we
% generate the RMSE vs RX-to-TX figure, treating the simulation results as
% ground truth.
groundTruthPlValues = simPLsForGridCalibrated;
rxToTxDistsInM3d = simGridPredResults.distsToTxInM3d;

% All path losses.
hFigPathLossOverDist = figure('visible', ~flagGenFigSilently); hold on;
hSim = plot(rxToTxDistsInM3d, groundTruthPlValues, 'bo');
hModSsc = plot(rxToTxDistsInM3d, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew, 'r*');
hModItu = plot(rxToTxDistsInM3d, ...
    simGridPredResults.ituPredictionsInDbNew, 'g.');
legend([hSim, hModItu, hModSsc], ...
    'Simulation', 'New ITU', 'New SS-C', 'Location', 'southeast');
grid on; grid minor;
xlabel('RX to TX distance (m)'); ylabel('Path loss (dB)');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'allPlsOverDist.png');
saveas(hFigPathLossOverDist, curFigPath);

% Shifting-window RMSE.
WINDOW_SIZE_IN_M = 10; % Needs to be an even number.

curXs = floor(min(rxToTxDistsInM3d+WINDOW_SIZE_IN_M/2)) ...
    :1:ceil(max(rxToTxDistsInM3d-WINDOW_SIZE_IN_M/2));
numOfCurXs = length(curXs);
[rmsesSscNew, rmsesItuNew] = deal(nan(numOfCurXs,1));
rmseFct = @(diff) sqrt(mean( diff.^2 ));
for idxX = 1:numOfCurXs
    curX = curXs(idxX);
    curXRangeMin = curX-WINDOW_SIZE_IN_M/2;
    curXRangeMax = curX+WINDOW_SIZE_IN_M/2;
    boolsGridPtsInCurRange = (rxToTxDistsInM3d>=curXRangeMin) ...
        & (rxToTxDistsInM3d<=curXRangeMax);
    rmsesSscNew(idxX) = rmseFct(sscVsSimZsNew(boolsGridPtsInCurRange));
    rmsesItuNew(idxX) = rmseFct(ituVsSimZsNew(boolsGridPtsInCurRange));
end

hFigWindowedRmse = figure('visible', ~flagGenFigSilently); hold on;
hItuNew = plot(curXs, rmsesItuNew, 'r*--');
hSscNew = plot(curXs, rmsesSscNew, 'b.-');
grid on; grid minor;
xlabel('RX to TX distance (m)'); ylabel('Windowed RMSE (dB)');
legend([hItuNew, hSscNew], ...
    'New ITU', 'New SS-C', 'Location', 'southeast');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'windowedRmse.png');
saveas(hFigWindowedRmse, curFigPath);

% For site-specific C model on measurements: path loss vs RX-to-TX
% distance. We will plot both the results for the old parameter values and
% those for the new parameter values.

% For ITU on measurements: path loss vs RX-to-TX distance. We will plot
% both the results for the old parameter values and those for the new
% parameter values.

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Save Workspace for Manual Inspection
disp('    Saving workspace for future inspectation...')
save(fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'workspace.mat'));
disp('    Done!');

%% Figures for Publication
disp('    Generating figures for publication...')

PATH_TO_SAVE_FIGS_FOR_PUBLICATION = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'epsFigsForPublication');
if exist(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, 'dir')~=7
    mkdir(PATH_TO_SAVE_FIGS_FOR_PUBLICATION);
end

customFigSize = [500, 500];

% Raw sim peak difference vs dist for tracks 1 and 8.
curTracksOfInterest = [1,8];
figSizeToSetForRawSim = [500, 235];
for idxTrack = curTracksOfInterest
    curDirToLoadSimResults = dirsToLoadSimResultsForEachTrack{idxTrack};
    if ~isempty(curDirToLoadSimResults)
        curSimLosses = loadSimLossFromExcel(curDirToLoadSimResults, 1);
        curSimLosses = curSimLosses(boolsToKeepMeas{idxTrack});
        
        assert(all(~isnan(curSimLosses)), ...
            'NaN value found in simulation results!');
        
        curMeasLosses = curContiPathLossesWithGpsInfo{idxTrack}(:,1);
        expectedNumOfSamps = length(curMeasLosses);
        
        % Load history TX to RX distance.
        curRxLocCsv = readtable(fullfile(ABS_PATH_TO_SIM_CSV_FILES, ...
            ['rxLoc_meas_', num2str(idxTrack), '.csv']));
        curRxToTx3DDistInM ...
            = curRxLocCsv.rxToTx3DDistInM(boolsToKeepMeas{idxTrack});
        
        [curSortedRxToTxDists, indicesSortByDist] ...
            = sort(curRxToTx3DDistInM);
        
        curSimLosses = curSimLosses(indicesSortByDist);
        curMeasLosses = curMeasLosses(indicesSortByDist);
        
        if expectedNumOfSamps>0
            % Plot raw simulation results and meassurements in the same
            % plot.
            hFigRawSimVsMeasByDist ...
                = figure('visible', ~flagGenFigSilently, ...
                'Position', [0,0,customFigSize]);
            hCurAxis = gca;
            hold on; set(hCurAxis, 'fontWeight', 'bold');
            yyaxis left;
            hSim = plot(curSortedRxToTxDists, curSimLosses, 'x--');
            % axis tight;
            xlabel('RX-to-TX Distance (m)');
            ylabel({'Ray Sampling Count'; 'Difference (dB)'});
            yyaxis right;
            hMeas = plot(curSortedRxToTxDists, curMeasLosses, '.-');
            % axis tight;
            ylabel('Path Loss (dB)');
            grid on; grid minor;
            legend([hSim, hMeas], 'Simulation', 'Measurement', ...
                'Location', 'southeast');
            adjustFigSizeByContent(hFigRawSimVsMeasByDist, axis, 'Width');
            set(hFigRawSimVsMeasByDist, ...
                'Position', [0, 0, figSizeToSetForRawSim]);
            pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
                ['RawSimVsMeasByDist_Track_', ...
                num2str(idxTrack)]);
            
            saveEpsFigForPaper(hFigRawSimVsMeasByDist, pathToSaveCurFig);
        end
    end
end

% Path loss vs dist for all tracks: the track-by-track calibration case.

% Path loss vs dist for all tracks: the one calibration for the whole grid
% case.
if strcmpi(simGridLossCalibMethod, 'cleanedmeasongrid') && false
    curSimLosses = vertcat(allSimLossesCleanedMeasOnGrid{:});
    curMeasLosses = vertcat(allMeasLossesCleanedMeasOnGrid{:});
    curRxToTx3DDistInM ...
        = vertcat(allRxToTx3DDistInMCleanedMeasOnGrid{:});
    
    [sortedRxToTxDistsGrid, indicesSortByDist] ...
        = sort(curRxToTx3DDistInM);
    
    curCalibratedSim = curSimLosses(indicesSortByDist);
    curMeasLosses = curMeasLosses(indicesSortByDist);
    lambda = physconst( 'LightSpeed' )/(F_C_IN_GHZ*10^9);
    curFspl = fspl(sortedRxToTxDistsGrid, lambda);
    
    curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));
    
    % The path loss over distance plot for all data.
    hFigSimGridVsMeasByDist = figure('visible', ~flagGenFigSilently, ...
        'Position', [0,0,customFigSize].*0.8);
    hCurAxis = gca;
    hold on; set(hCurAxis, 'fontWeight', 'bold');
    hSim = plot(sortedRxToTxDistsGrid, ...
        curCalibratedSim-curFspl, 'x');
    hMeas = plot(sortedRxToTxDistsGrid, ...
        curMeasLosses-curFspl, '.');
    % title(['Overall RMSD = ', num2str(curRmsd, '%.2f'), ' dB']);
    xlabel('RX-to-TX Distance (m)'); ylabel('Excess Path Loss (dB)');
    grid on; grid minor; axis tight;
    adjustFigSizeByContent(hFigAreaOfInterest, axis, 'width');
    if ~isempty(hSim)
        legend([hSim, hMeas], 'Simulation', 'Measurement', ...
            'Location', 'SouthEast');
    end
    
    pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
        'simGridResultsVsMeas');
    saveEpsFigForPaper(hFigSimGridVsMeasByDist, pathToSaveCurFig);
end

% Save RMSE for each track and the overall RMSE to a txt file with & as
% delimiter (for use of latex): the track-by-track calibration case.
curRmsdsStr = '';
for idxTrack =1:numOfTracks
    curDirToLoadSimResults = dirsToLoadSimResultsForEachTrack{idxTrack};
    if ~isempty(curDirToLoadSimResults)
        curSimLosses = loadSimLossFromExcel(curDirToLoadSimResults, 1);
        curSimLosses = curSimLosses(boolsToKeepMeas{idxTrack});
        
        assert(all(~isnan(curSimLosses)), ...
            'NaN value found in simulation results!');
        
        curMeasLosses = curContiPathLossesWithGpsInfo{idxTrack}(:,1);
        expectedNumOfSamps = length(curMeasLosses);
        
        % Load history TX to RX distance.
        curRxLocCsv = readtable(fullfile(ABS_PATH_TO_SIM_CSV_FILES, ...
            ['rxLoc_meas_', num2str(idxTrack), '.csv']));
        curRxToTx3DDistInM ...
            = curRxLocCsv.rxToTx3DDistInM(boolsToKeepMeas{idxTrack});
        
        [curSortedRxToTxDists, indicesSortByDist] ...
            = sort(curRxToTx3DDistInM);
        
        curSimLosses = curSimLosses(indicesSortByDist);
        curMeasLosses = curMeasLosses(indicesSortByDist);
        
        [curCalibratedSim, curBestShift, curMultiFactor] ...
            = calibrateSimPlsWithMeas(curSimLosses, curMeasLosses);
        curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));
        
        curRmsdsStr ...
            = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];
        
        curAllSimLosses{idxTrack} = curCalibratedSim;
        curAllMeasLosses{idxTrack} = curMeasLosses;
    end
end

% The overall RMSE for the first 5 tracks.
curCalibratedSim = vertcat(curAllSimLosses{1:5});
curMeasLosses = vertcat(curAllMeasLosses{1:5});
curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));

curRmsdsStr = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];

% The overall RMSE for the last 5 tracks.
curCalibratedSim = vertcat(curAllSimLosses{6:10});
curMeasLosses = vertcat(curAllMeasLosses{6:10});
curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));

curRmsdsStr = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];

% The overall RMSE.
curCalibratedSim = vertcat(curAllSimLosses{:});
curMeasLosses = vertcat(curAllMeasLosses{:});
curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));

curRmsdsStr = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];

pathToSaveCurMat = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'TrackWiseRmses.txt');
fid = fopen(pathToSaveCurMat, 'w');
fprintf(fid, curRmsdsStr);
fclose(fid);

% Save RMSE for each track to a txt file with & as delimiter (for use of
% latex): the one calibration for the whole grid case.
if strcmpi(simGridLossCalibMethod, 'cleanedmeasongrid')
    curRmsdsStr = '';
    for idxTrack =1:numOfTracks
        curCalibratedSim = allSimLossesCleanedMeasOnGrid{idxTrack};
        curMeasLosses = allMeasLossesCleanedMeasOnGrid{idxTrack};
        
        curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));
        
        curRmsdsStr ...
            = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];
    end
    
    % The overall RMSE for the first 5 tracks.
    curCalibratedSim = vertcat(allSimLossesCleanedMeasOnGrid{1:5});
    curMeasLosses = vertcat(allMeasLossesCleanedMeasOnGrid{1:5});
    curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));
    
    curRmsdsStr = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];
    
    % The overall RMSE for the last 5 tracks.
    curCalibratedSim = vertcat(allSimLossesCleanedMeasOnGrid{6:10});
    curMeasLosses = vertcat(allMeasLossesCleanedMeasOnGrid{6:10});
    curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));
    
    curRmsdsStr = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];
    
    % The overall RMSE.
    curCalibratedSim = vertcat(allSimLossesCleanedMeasOnGrid{:});
    curMeasLosses = vertcat(allMeasLossesCleanedMeasOnGrid{:});
    curRmsd = sqrt(mean((curCalibratedSim-curMeasLosses).^2));
    
    curRmsdsStr = [curRmsdsStr, ' & ', num2str(curRmsd, '%.1f')];
    
    pathToSaveCurMat = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
        'TrackWiseRmses_Grid.txt');
    fid = fopen(pathToSaveCurMat, 'w');
    fprintf(fid, curRmsdsStr);
    fclose(fid);
end

% The grid with measured locs.
allContiPathLossesWithGpsInfo ...
    = vertcat(contiPathLossesWithGpsInfo{:});
rxLons = allContiPathLossesWithGpsInfo(:,3);
rxLats = allContiPathLossesWithGpsInfo(:,2);

% A UTM plot for determining the axis to set.
hFigAreaOfInterest = figure('visible', false); hold on;
hAreaOfInterest = plot( ...
    simGrid.xYRangePolyshape, ...
    'FaceColor', areaOfInterestColor);
hGridPts = plot(simGrid.utmXYs(:,1), ...
    simGrid.utmXYs(:,2), '.b', 'MarkerSize', 3, 'Color', darkBlue);
axis equal; view(2);
adjustFigSizeByContent(hFigAreaOfInterest, axis, 'width');
axisToSetUtm = axis;
figPosToSet = get(hFigAreaOfInterest, 'Position');
close(hFigAreaOfInterest);

[axisToSetMinLat, axisToSetMinLon] ...
    = utm2deg(axisToSetUtm(1), axisToSetUtm(3), txUtmZone);
[axisToSetMaxLat, axisToSetMaxLon] ...
    = utm2deg(axisToSetUtm(2), axisToSetUtm(4), txUtmZone);
axisToSet = [axisToSetMinLon, axisToSetMaxLon, ...
    axisToSetMinLat, axisToSetMaxLat];

hFigGrid = figure('visible', ~flagGenFigSilently, ...
    'Position', [0,0,customFigSize].*0.8);
hCurAxis = gca;
hold on; set(hCurAxis, 'fontWeight', 'bold');
hAreaOfInterest = plot( ...
    simGrid.latLonRangePolyshape, ...
    'FaceColor', areaOfInterestColor);
hGridPts = plot(simGrid.latLons(:, 2), ...
    simGrid.latLons(:,1), '.b', 'MarkerSize', 3.5, 'Color', darkBlue);
hRxs = plot(rxLons, rxLats, 'rx', 'LineWidth', 1);
hTx = plot(lonTx, latTx, 'b^', 'LineWidth', 2);
view(2);
set(hFigGrid, 'Position', figPosToSet);
axis(axisToSet);
plot_google_map;
xticks([]); yticks([]); xlabel('Longitude'); ylabel('Latitude');
box on;
legend([hAreaOfInterest, hGridPts, hTx, hRxs], ...
    'Extended Area of Interest', 'Grid Points', 'TX', ...
    'Measured Locations', 'Location', 'SouthEast', 'AutoUpdate', 'off');
% transparentizeCurLegends;
makescale('sw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'Overview_Grid');
saveEpsFigForPaper(hFigGrid, pathToSaveCurFig);

% Overview of the simulation results.
allPathlossValues = [ simPLsForGridCalibrated; ...
    simGridPredResults.ituPredictionsInDbOld; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
simConfigs.ALLOWED_PATH_LOSS_RANGE_IN_DB ...
    = [floor(min(allPathlossValues)./10), ...
    ceil(max(allPathlossValues)./10)].*10;

customFigSizeForSurfMap = customFigSize.*0.6;

matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simPLsForGridCalibrated];
colorbarTitle = 'Path Loss (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn, ...
    'surf', customFigSizeForSurfMap);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast', 'AutoUpdate', 'off');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);
makescale('nw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'surfOverview_SimGridPLs');
saveEpsFigForPaper(hCurPLMap, pathToSaveCurFig);

% Overview of the results from site-specific model C.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
colorbarTitle = 'Path Loss (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn, ...
    'surf', customFigSizeForSurfMap);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast', 'AutoUpdate', 'off');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);
makescale('nw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'surfOverview_SscPLs');
saveEpsFigForPaper(hCurPLMap, pathToSaveCurFig);

% Overview of the results from ITU.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbOld];
colorbarTitle = 'Path Loss (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn, ...
    'surf', customFigSizeForSurfMap);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast', 'AutoUpdate', 'off');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);
makescale('nw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'surfOverview_ItuPLs');
saveEpsFigForPaper(hCurPLMap, pathToSaveCurFig);

% Overview of the results from site-specific model C - simulation results.
customFigSizeForSurfDiff = customFigSize.*0.4;

allPathlossValues = [ sscVsSimZsOld; ituVsSimZsOld ];
simConfigs.ALLOWED_PATH_LOSS_RANGE_IN_DB ...
    = [floor(min(allPathlossValues)./10), ...
    ceil(max(allPathlossValues)./10)].*10;

matRxLonLatWithPathLoss = [simGridLons, simGridLats, sscVsSimZsOld];
colorbarTitle = {'Difference w.r.t.' ; 'Simulation (dB)'};

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLoss(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn, ...
    'surf', customFigSizeForSurfDiff);
xlabel(''); ylabel('')
legend(hCurHandleTxs, 'TX', 'Location', 'southeast', 'AutoUpdate', 'off');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, ''); box on;
ylabel(hCb, colorbarTitle, 'FontSize', 9, 'Position', [2.1,-15]);
% makescale('nw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'surfOverview_SscPLs_minusSim');
saveEpsFigForPaper(hCurPLMap, pathToSaveCurFig);

% Overview of the results from ITU - simulation results.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ituVsSimZsOld];
colorbarTitle = {'Difference w.r.t.' ; 'Simulation (dB)'};

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLoss(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn, ...
    'surf', customFigSizeForSurfDiff);
xlabel(''); ylabel('')
legend(hCurHandleTxs, 'TX', 'Location', 'southeast', 'AutoUpdate', 'off');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, ''); box on;
ylabel(hCb, colorbarTitle, 'FontSize', 9, 'Position', [2.1,-15]);
% makescale('nw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'surfOverview_ItuPLs_minusSim');
saveEpsFigForPaper(hCurPLMap, pathToSaveCurFig);

% All simulation results with ITU and SS-C predictions over distance.
figureSizeToSet = [350 160];

hFigPathLossOverDist = figure('visible', ~flagGenFigSilently, ...
    'Position', [0,0,customFigSize].*0.8);
hCurAxis = gca;
hold on; set(hCurAxis, 'fontWeight', 'bold');
hSim = plot(rxToTxDistsInM3d, groundTruthPlValues, 'bo', 'MarkerSize', 3);
hModSsc = plot(rxToTxDistsInM3d, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld, 'rx', ...
    'MarkerSize', 5);
hModItu = plot(rxToTxDistsInM3d, ...
    simGridPredResults.ituPredictionsInDbOld, 'g.', 'MarkerSize', 6);
axis tight; axisToSet = axis; axisToSet(1) = 0;
adjustFigSizeByContent(hFigPathLossOverDist, axisToSet, 'Width', 0.6);
set(hFigPathLossOverDist, 'Position', [0 0 figureSizeToSet]);
legend([hSim, hModItu, hModSsc], ...
    'Simulation', 'ITU', 'Site-Specific Model C', 'Location', 'southeast');
grid on; grid minor;
xlabel('RX to TX Distance (m)'); ylabel('Path Loss (dB)');

curFigPath = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'allPlsOverDist');
saveEpsFigForPaper(hFigPathLossOverDist, curFigPath);

% Regional RMSD.
WINDOW_SIZE_IN_M = 10; % Needs to be an even number.

curXs = floor(min(rxToTxDistsInM3d+WINDOW_SIZE_IN_M/2)) ...
    :1:ceil(max(rxToTxDistsInM3d-WINDOW_SIZE_IN_M/2));
numOfCurXs = length(curXs);
[rmsesSscOld, rmsesItuOld] = deal(nan(numOfCurXs,1));
rmseFct = @(diff) sqrt(mean( diff.^2 ));

boolsRxLocItuBetter = false(size(rxToTxDistsInM3d));
maxRmsesImprovementWithItu = -inf(size(rxToTxDistsInM3d));

for idxX = 1:numOfCurXs
    curX = curXs(idxX);
    curXRangeMin = curX-WINDOW_SIZE_IN_M/2;
    curXRangeMax = curX+WINDOW_SIZE_IN_M/2;
    boolsGridPtsInCurRange = (rxToTxDistsInM3d>=curXRangeMin) ...
        & (rxToTxDistsInM3d<=curXRangeMax);
    rmsesSscOld(idxX) = rmseFct(sscVsSimZsOld(boolsGridPtsInCurRange));
    rmsesItuOld(idxX) = rmseFct(ituVsSimZsOld(boolsGridPtsInCurRange));
    
    if rmsesItuOld(idxX)<rmsesSscOld(idxX)
        rmseDiff = rmsesSscOld(idxX)-rmsesItuOld(idxX);
        boolsRxLocItuBetter ...
            = boolsRxLocItuBetter | boolsGridPtsInCurRange;
        maxRmsesImprovementWithItu(boolsRxLocItuBetter) ...
            = max(maxRmsesImprovementWithItu(boolsRxLocItuBetter), ...
            rmseDiff.*ones( ...
            size(maxRmsesImprovementWithItu(boolsRxLocItuBetter))));
    end
end

hFigWindowedRmsd = figure('visible', ~flagGenFigSilently, ...
    'Position', [0,0,customFigSize].*0.8);
hCurAxis = gca;
hold on; set(hCurAxis, 'fontWeight', 'bold');
hSscOld = plot(curXs, rmsesSscOld, 'rx', ...
    'MarkerSize', 5);
hItuOld = plot(curXs, rmsesItuOld, 'g.', 'MarkerSize', 6);
curAxis = axis;
adjustFigSizeByContent(hFigWindowedRmsd, ...
    [axisToSet(1:2), curAxis(3:4)] , 'Width', 0.1);
set(hFigWindowedRmsd, 'Position', [0 0 figureSizeToSet]);
grid on; grid minor;
xlabel('RX to TX distance (m)'); ylabel('Regional RMSD (dB)');
legend([hItuOld, hSscOld], ...
    'ITU', 'Site-Specific Model C', 'Location', 'north');

curFigPath = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'windowedRmsdForItuAndSsc');
saveEpsFigForPaper(hFigWindowedRmsd, curFigPath);

% Locations where ITU performs better.
colorRangeMax = ceil(max( ...
    abs([min(maxRmsesImprovementWithItu(boolsRxLocItuBetter)), ...
    max(maxRmsesImprovementWithItu(boolsRxLocItuBetter))])));
% We neeed to shift the plot3k result vertically to avoid obstruction by
% the Google map image at z=0.
shiftInZ = colorRangeMax+1;

curFigTitle = {'Simulation Grid Locations'; ...
    'with Better ITU Regional RMSE'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridLocsWithBetterItuRegionalRmse.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;
hTx = plot3(lonTx, latTx, TX_HEIGHT_M,'gx');
hRx = plot3k([simGrid.latLons(boolsRxLocItuBetter,2), ...
    simGrid.latLons(boolsRxLocItuBetter,1), ...
    maxRmsesImprovementWithItu(boolsRxLocItuBetter)+shiftInZ], ...
    'Labels', {curFigTitle, 'Longtitude', 'Latitude', '', ...
    'ITU Improvemenet (dB)'}, ...
    'ColorRange', [-colorRangeMax, colorRangeMax]+shiftInZ);
plot_google_map('MapType', 'satellite');
% The command plot_google_map messes up the color legend of plot3k, so we
% will have to fix it here.
hCb = findall( allchild(curFig), 'type', 'colorbar');
hCb.Ticks = linspace(1,length(colormap)+1,length(hCb.TickLabels));
% We also need to fix the wrong labels because of the shift along the z
% axis.
hCb.TickLabels = ...
    arrayfun(@(n) {num2str(n-shiftInZ)}, cellfun(@(l) str2num(l), ...
    hCb.TickLabels));

zlim([0, colorRangeMax+shiftInZ]); view(2); xticks([]); yticks([]);
legend(hTx, 'TX', ...
    'Location', 'SouthEast');
transparentizeCurLegends;

saveas(curFig, curFigPath);

% Locations where ITU performs better in a point-wise manner.
rmsesImprovementWithItu = abs(sscVsSimZsOld) - abs(ituVsSimZsOld);
colorRangeMax = ceil(max( ...
    abs([min(rmsesImprovementWithItu(boolsRxLocItuBetter)), ...
    max(rmsesImprovementWithItu(boolsRxLocItuBetter))])));
% We neeed to shift the plot3k result vertically to avoid obstruction by
% the Google map image at z=0.
shiftInZ = colorRangeMax+1;

curFigTitle = {'Simulation Grid Locations (Point-Wise)'; ...
    'with Better ITU Regional RMSE'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridLocsWithBetterItuRegionalRmsePointWise.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;
hTx = plot3(lonTx, latTx, TX_HEIGHT_M,'gx');
hRx = plot3k([simGrid.latLons(boolsRxLocItuBetter,2), ...
    simGrid.latLons(boolsRxLocItuBetter,1), ...
    rmsesImprovementWithItu(boolsRxLocItuBetter)+shiftInZ], ...
    'Labels', {curFigTitle, 'Longtitude', 'Latitude', '', ...
    'ITU Improvemenet (dB)'}, ...
    'ColorRange', [-colorRangeMax, colorRangeMax]+shiftInZ);
plot_google_map('MapType', 'satellite');
% The command plot_google_map messes up the color legend of plot3k, so we
% will have to fix it here.
hCb = findall( allchild(curFig), 'type', 'colorbar');
hCb.Ticks = linspace(1,length(colormap)+1,length(hCb.TickLabels));
% We also need to fix the wrong labels because of the shift along the z
% axis.
hCb.TickLabels = ...
    arrayfun(@(n) {num2str(n-shiftInZ)}, cellfun(@(l) str2num(l), ...
    hCb.TickLabels));

zlim([0, colorRangeMax+shiftInZ]); view(2); xticks([]); yticks([]);
legend(hTx, 'TX', ...
    'Location', 'SouthEast');
transparentizeCurLegends;

title(curFigTitle)
saveas(curFig, curFigPath);

% Regional RMSD for in-forest RX locations only according to the manually
% labeled forest edge polygon.
[clearanceZoneBoundXs, clearanceZoneBoundYs] = deg2utm( ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2));
boolsRxLocInForest ...
    = ~inpolygon(simGrid.utmXYs(:,1), simGrid.utmXYs(:,2), ...
    clearanceZoneBoundXs, clearanceZoneBoundYs);

curXsInF = floor( ...
    min(rxToTxDistsInM3d(boolsRxLocInForest)...
    +WINDOW_SIZE_IN_M/2)) ...
    :1:ceil(max(rxToTxDistsInM3d(boolsRxLocInForest)...
    -WINDOW_SIZE_IN_M/2));
numOfCurXsInF = length(curXsInF);
[rmsesSscOldInF, rmsesItuOldInF] = deal(nan(numOfCurXsInF,1));
rmseFct = @(diff) sqrt(mean( diff.^2 ));
for idxXInF = 1:numOfCurXsInF
    curX = curXsInF(idxXInF);
    curXRangeMin = curX-WINDOW_SIZE_IN_M/2;
    curXRangeMax = curX+WINDOW_SIZE_IN_M/2;
    boolsGridPtsInCurRange = (rxToTxDistsInM3d>=curXRangeMin) ...
        & (rxToTxDistsInM3d<=curXRangeMax);
    rmsesSscOldInF(idxXInF) = rmseFct(sscVsSimZsOld( ...
        boolsGridPtsInCurRange & boolsRxLocInForest));
    rmsesItuOldInF(idxXInF) = rmseFct(ituVsSimZsOld( ...
        boolsGridPtsInCurRange & boolsRxLocInForest));
end

hFigWindowedRmsdInForest = figure('visible', ~flagGenFigSilently, ...
    'Position', [0,0,customFigSize].*0.8);
hCurAxis = gca;
hold on; set(hCurAxis, 'fontWeight', 'bold');
hSscOld = plot(curXsInF, rmsesSscOldInF, 'rx', ...
    'MarkerSize', 5);
hItuOld = plot(curXsInF, rmsesItuOldInF, 'g.', 'MarkerSize', 6);
curAxis = axis;
adjustFigSizeByContent(hFigWindowedRmsdInForest, ...
    [axisToSet(1:2), curAxis(3:4)] , 'Width', 0.1);
set(hFigWindowedRmsdInForest, 'Position', [0 0 figureSizeToSet]);
grid on; grid minor;
xlabel('RX to TX distance (m)'); ylabel('Regional RMSD (dB)');
legend([hItuOld, hSscOld], ...
    'ITU', 'Site-Specific Model C', 'Location', 'north');

curFigPath = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'windowedRmsdForItuAndSscInForest');
saveEpsFigForPaper(hFigWindowedRmsdInForest, curFigPath);

%% Regional RMSD for in-forest RX locations only according to the manually
% labeled forest edge polygon and the foliage area results.
[clearanceZoneBoundXs, clearanceZoneBoundYs] = deg2utm( ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2));
boolsRxLocInForestStrict ...
    = ~(inpolygon(simGrid.utmXYs(:,1), simGrid.utmXYs(:,2), ...
    clearanceZoneBoundXs, clearanceZoneBoundYs)| ...
    (simGridPredResults.foliageAreasInFirstFresnel==0));

curXsInFS = floor( ...
    min(rxToTxDistsInM3d(boolsRxLocInForestStrict)...
    +WINDOW_SIZE_IN_M/2)) ...
    :1:ceil(max(rxToTxDistsInM3d(boolsRxLocInForestStrict)...
    -WINDOW_SIZE_IN_M/2));
numOfCurXsInFS = length(curXsInFS);
[rmsesSscOldInFS, rmsesItuOldInFS] = deal(nan(numOfCurXsInFS,1));
rmseFct = @(diff) sqrt(mean( diff.^2 ));
for idxXInFS = 1:numOfCurXsInFS
    curX = curXsInFS(idxXInFS);
    curXRangeMin = curX-WINDOW_SIZE_IN_M/2;
    curXRangeMax = curX+WINDOW_SIZE_IN_M/2;
    boolsGridPtsInCurRange = (rxToTxDistsInM3d>=curXRangeMin) ...
        & (rxToTxDistsInM3d<=curXRangeMax);
    rmsesSscOldInFS(idxXInFS) = rmseFct(sscVsSimZsOld( ...
        boolsGridPtsInCurRange & boolsRxLocInForestStrict));
    rmsesItuOldInFS(idxXInFS) = rmseFct(ituVsSimZsOld( ...
        boolsGridPtsInCurRange & boolsRxLocInForestStrict));
end

hFigWindowedRmsdInForestStrict = figure('visible', ~flagGenFigSilently, ...
    'Position', [0,0,customFigSize].*0.8);
hCurAxis = gca;
hold on; set(hCurAxis, 'fontWeight', 'bold');
hSscOld = plot(curXsInFS, rmsesSscOldInFS, 'rx', ...
    'MarkerSize', 5);
hItuOld = plot(curXsInFS, rmsesItuOldInFS, 'g.', 'MarkerSize', 6);
curAxis = axis;
adjustFigSizeByContent(hFigWindowedRmsdInForestStrict, ...
    [axisToSet(1:2), curAxis(3:4)] , 'Width', 0.1);
set(hFigWindowedRmsdInForestStrict, 'Position', [0 0 figureSizeToSet]);
grid on; grid minor;
xlabel('RX to TX distance (m)'); ylabel('Regional RMSD (dB)');
legend([hItuOld, hSscOld], ...
    'ITU', 'Site-Specific Model C', 'Location', 'north');

curFigPath = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'windowedRmsdForItuAndSscInForestStrict');
saveEpsFigForPaper(hFigWindowedRmsdInForestStrict, curFigPath);

% Simulation results with ITU and SS-C predictions over distance strictly
% in the forest.
figureSizeToSet = [350 160];

hFigPathLossOverDist = figure('visible', ~flagGenFigSilently, ...
    'Position', [0,0,customFigSize].*0.8);
hCurAxis = gca;
hold on; set(hCurAxis, 'fontWeight', 'bold');
hSim = plot(rxToTxDistsInM3d(boolsRxLocInForestStrict), ...
    groundTruthPlValues(boolsRxLocInForestStrict), 'bo', 'MarkerSize', 3);
hModSsc = plot(rxToTxDistsInM3d(boolsRxLocInForestStrict), ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld( ...
    boolsRxLocInForestStrict), 'rx', ...
    'MarkerSize', 5);
hModItu = plot(rxToTxDistsInM3d(boolsRxLocInForestStrict), ...
    simGridPredResults.ituPredictionsInDbOld(boolsRxLocInForestStrict), ...
    'g.', 'MarkerSize', 6);
axis tight; axisToSet = axis; axisToSet(1) = 0;
adjustFigSizeByContent(hFigPathLossOverDist, axisToSet, 'Width', 0.6);
set(hFigPathLossOverDist, 'Position', [0 0 figureSizeToSet]);
legend([hSim, hModItu, hModSsc], ...
    'Simulation', 'ITU', 'Site-Specific Model C', 'Location', 'southeast');
grid on; grid minor;
xlabel('RX to TX Distance (m)'); ylabel('Path Loss (dB)');

curFigPath = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'allPlsOverDistInForestStrict');
saveEpsFigForPaper(hFigPathLossOverDist, curFigPath);

%% Overview of the results from ITU - simulation results with forest edge.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ituVsSimZsOld];
colorbarTitle = {'Difference w.r.t.' ; 'Simulation (dB)'};

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLoss(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn, ...
    'surf', customFigSizeForSurfDiff);
xlabel(''); ylabel('')
legend(hCurHandleTxs, 'TX', ...
    'Location', 'southeast', 'AutoUpdate', 'off');
% Sim grid boundary. Note the points in simGrid.latLonRangePolyshape is
% actually arranged as (lon, lat).
hSimGridBound = plot(simGrid.latLonRangePolyshape, ...
    'FaceColor', 'none', 'LineWidth', 1);
% Forest edge.
hForestEdge = plot( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
    'k:', 'LineWidth', 1);
% extraAx = axes('position',get(gca,'position'),'visible','off');
% leg2 = legend(extraAx, hForestEdge, 'Forest Edge', ...
%     'Location', 'northwest', 'AutoUpdate', 'off');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, ''); box on;
ylabel(hCb, colorbarTitle, 'FontSize', 9, 'Position', [2.1,-15]);
% makescale('nw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'surfOverview_ItuPLs_minusSim_withForestEdge');
saveEpsFigForPaper(hCurPLMap, pathToSaveCurFig);

%% Overview of the results from site-specific model C - simulation results
% with zero foliage area.
boolsZeroFoliageArea = simGridPredResults.foliageAreasInFirstFresnel==0;
zeroFoliageAreaLonLatShape = alphaShape( ...
    simGridLons(boolsZeroFoliageArea), simGridLats(boolsZeroFoliageArea));
zeroFoliageAreaLonLatShape.Alpha = zeroFoliageAreaLonLatShape.Alpha/3.75;
zeroFoliageAreaLonLatShape.RegionThreshold ...
    = area(zeroFoliageAreaLonLatShape)/2;
zeroFoliageAreaLonLatShapeEdgePtInds ...
    = boundaryFacets(zeroFoliageAreaLonLatShape);
zeroFoliageAreaLonLatShapeEdgePtInds ...
    = [zeroFoliageAreaLonLatShapeEdgePtInds(:,1); ...
    zeroFoliageAreaLonLatShapeEdgePtInds(end,2)];
zeroFoliageAreaLonLatShapeEdge = zeroFoliageAreaLonLatShape.Points(...
   zeroFoliageAreaLonLatShapeEdgePtInds, :);

customFigSizeForSurfDiff = customFigSize.*0.4;

allPathlossValues = [ sscVsSimZsOld; ituVsSimZsOld ];
simConfigs.ALLOWED_PATH_LOSS_RANGE_IN_DB ...
    = [floor(min(allPathlossValues)./10), ...
    ceil(max(allPathlossValues)./10)].*10;

matRxLonLatWithPathLoss = [simGridLons, simGridLats, sscVsSimZsOld];
colorbarTitle = {'Difference w.r.t.' ; 'Simulation (dB)'};

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLoss(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn, ...
    'surf', customFigSizeForSurfDiff);
xlabel(''); ylabel('')
legend(hCurHandleTxs, 'TX', 'Location', 'southeast', 'AutoUpdate', 'off');
% Sim grid boundary. Note the points in simGrid.latLonRangePolyshape is
% actually arranged as (lon, lat).
hSimGridBound = plot(simGrid.latLonRangePolyshape, ...
    'FaceColor', 'none', 'LineWidth', 1);
% Zero foliage area region.
hZeroFoliageArea = plot( ...
    zeroFoliageAreaLonLatShapeEdge(:,1), ...
    zeroFoliageAreaLonLatShapeEdge(:,2), ...
    'k:', 'LineWidth', 1);
% extraAx = axes('position',get(gca,'position'),'visible','off');
% leg2 = legend(extraAx, hForestEdge, 'Zero Foliage Area Zone', ...
%     'Location', 'northwest', 'AutoUpdate', 'off');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, ''); box on;
ylabel(hCb, colorbarTitle, 'FontSize', 9, 'Position', [2.1,-15]);
% makescale('nw', 'units', 'si');

pathToSaveCurFig = fullfile(PATH_TO_SAVE_FIGS_FOR_PUBLICATION, ...
    'surfOverview_SscPLs_minusSim_withZeroFoliageAreaZone');
saveEpsFigForPaper(hCurPLMap, pathToSaveCurFig);

%% Close all figures if necessary.
if flagGenFigSilently
    close all;
end

disp('    Done!');

% EOF