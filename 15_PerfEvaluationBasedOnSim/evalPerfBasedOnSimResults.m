%EVALPERFBASEDONSIMRESULTS Evaluation the performance of site-specific
%models according to the simulation results from Lab
%
% Yaguang Zhang, Purdue, 09/13/2019

clearvars -except getUsgsEleInMFromUtmXY; clc; close all;

%% Configurations

warning('on');

% Add libs to current path and set ABS_PATH_TO_NIST_SHARED_FOLDER according
% to the machine name.
cd(fileparts(mfilename('fullpath')));
addpath(fullfile(pwd));
cd('..'); setPath;

% We will need computeFreeSpacePathLosses.m.
addpath(fullfile(pwd, '4_FoliageAttenuationEstimation'));

% We will need the functions latLon2PixIndices.m and pixIndices2LatLon.m
% for working with the vegArea image.
addpath(fullfile(pwd, '9_GenerateVegAreas'));

% We will need the functions countNumOfFoliagePixelsInFirstFresnelZone.m
addpath(fullfile(pwd, '10_CompareFoliageDepthBasedModels'));

% Path to the simulation result xlsx files.
ABS_DIR_TO_SIM_RESULTS = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'Data', '20191011_NistFoliageSimulationResults');

% Path to the simulation result xlsx files.
ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'Data', '20191016_NistFoliageSimulationResultsForGrid', ...
    'var_grnd_grid_propagation_stats_20191026.xlsx');

% Configure other paths accordingly.
ABS_PATH_TO_SAVE_PLOTS = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PerformanceEvaluationBasedOnSimulations');

% Reuse results from evalPathLossesForContiTracks.m and
% loadMeasCampaignInfo.m.
ABS_PATH_TO_PATH_LOSSES_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputationConti', ...
    'contiPathLossesWithGpsInfo.mat');
ABS_PATH_TO_TX_INFO_LOGS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputation', 'txInfoLogs.mat');

% Reuse results from generateVegAreas.m.
ABS_PATH_TO_VEG_AREAS_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'AutoGeneratedVegAreas', 'vegAreasMeta.mat');

% Reuse results from estimateFoliageAttenuation.m.
ABS_PATH_TO_UTM_INFO_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'FoliageAttenuationEstimation', ...
    'utmInfoForPathLossesAndTrees.mat');

% Reuse results from estimateFoliageAttenuationWithManualTreeLocs.m.
ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageAttenuationEstimation_ManualTreeLocs', ...
    'foliageAttenAnalysisResults.mat');

% Reuse results from compareFoliageDepthBasedModels.m.
ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageDepthBasedModelsComparison', ...
    'foliageDepthBasedAttenAnalysisResults.mat');

% Reuse results from inspectOutlayers.m.
ABS_PATH_TO_BEAM_POLYGONS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    '13_OutlayerInspection', ...
    'beamPolygons.mat');

% Reuse .csv files exported for simulation.
ABS_PATH_TO_SIM_CSV_FILES ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'SimulationDataExportationExtended');

% The lengths of path within woodland (for the ITU model) and site-specific
% foilage areas will be saved into a file.
pathToSavePredictionsForGrid ...
    = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'predictionsForExtendedGrid.mat');

% The predictions from selected models will be saved.
pathToSaveGrid ...
    = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simulationGrid.mat');

% The 3 segment for length of path within woodland for evaluating the
% performance (root-mean-square deviation) for the ITU model. Each segment
% will be the min and max values in the form of [min, max), i.e. including
% min but excluding max.
segmentsForRmsdDw = {[0,30], [30,220], [220, inf]};

% The 3 segment for the foliage depth for evaluating the performance of
% Weissberger's model. Each segment will be the min and max values in the
% form of [min, max), i.e. including min but excluding max.
segmentsForRmsdDf = {[0,15], [15,75], [75, inf]};

% The updated tree locations.
ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'ManuallyLocateMoreTrees', 'treeLocs.mat');

% For creating a grid to cover a larger area than that covered by our
% measurements. We will need the (latitude, longitude) range polygon stored
% as a polyshape to determin which area to cover.
latLonEdgesDeterminedByTerrain = {[39.992772, -105.275100; ...
    39.990018, -105.278469]; ...
    [39.989118, -105.276475; ...
    39.991211, -105.272842]};

% Control the truncation of the data in the output .csv files.
dataStrFormatter = '%.12f';

% For plotting.
lightGray = ones(1,3).*0.7;

% We will use this number of pixels for the longer side (width/height) of
% the simulation area; the number of pixels for the other side will be
% proportional to its length.
simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE = 100;

% For plotting.
areaOfInterestColor = [0.9290 0.6940 0.1250];
lightBlue = [0.3010 0.7450 0.9330];
darkBlue = [0 0.4470 0.7410];

% Set this to true to avoid showing the figures while they are being
% generated.
flagGenFigSilently = true;

% The measurement area.
figAxisToSet = [-105.2774429259207, -105.2744429246357, ...
    39.9893839683981, 39.9915745444857];

%% Before Processing the Data

curFileName = mfilename;
fileNameHintRuler = [' ', repmat('-', 1, length(curFileName)+2), ' '];
disp(fileNameHintRuler)
disp(['  ', curFileName, '  '])
disp(fileNameHintRuler)

% Create directories if necessary.
if exist(ABS_PATH_TO_SAVE_PLOTS, 'dir')~=7
    mkdir(ABS_PATH_TO_SAVE_PLOTS);
end

%% Get Info for Measurement Data Files and Calibration Polynomials

disp(' ')
disp('    Loading results from: ')
disp('      - contiPathLossesWithGpsInfo.mat')
disp('      - txInfoLogs.mat')
disp('      - vegAreasMeta.mat')
disp('      - utmInfoForPathLossesAndTrees.mat')
disp('      - treeLocs.mat (Extended)')

assert(exist(ABS_PATH_TO_PATH_LOSSES_FILE, 'file')==2, ...
    'Couldn''t find contiPathLossesWithGpsInfo.mat! Please run 3_PathLossComputation/evalPathLossesForContiTracks.m first.');
assert(exist(ABS_PATH_TO_TX_INFO_LOGS_FILE, 'file')==2, ...
    'Couldn''t find txInfoLogs.mat! Please run 3_PathLossComputation/loadMeasCampaignInfo.m first.');
assert(exist(ABS_PATH_TO_VEG_AREAS_FILE, 'file')==2, ...
    'Couldn''t find vegAreasMeta.mat! Please run 9_GenerateVegAreas/generateVegAreas.m first.');
assert(exist(ABS_PATH_TO_UTM_INFO_FILE, 'file')==2, ...
    'Couldn''t find utmInfoForPathLossesAndTrees.mat! Please run 4_FoliageAttenuationEstimation/estimateFoliageAttenuation.m first.');
assert(exist(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE, 'file')==2, ...
    'Couldn''t find foliageAttenAnalysisResults.mat! Please run 8_FoliageAttenuationEstimation_ManualTreeLocs/estimateFoliageAttenuationWithManualTreeLocs.m first.');
assert(exist(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, 'file')==2, ...
    'Couldn''t find foliageDepthBasedAttenAnalysisResults.mat! Please run 10_CompareFoliageDepthBasedModels/compareFoliageDepthBasedModels.m first.');
assert(exist(ABS_PATH_TO_BEAM_POLYGONS_FILE, 'file')==2, ...
    'Couldn''t find beamPolygons.mat! Please run 13_OutlayerInspection/inspectOutlayers.m first.');
assert(exist(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS, 'file')==2, ...
    'Couldn''t find treeLocs.mat! Please run NistMeasurementCampaignCode/15_PerfEvaluationBasedOnSim/manuallyLocateMoreTrees.m first.');


% The data have been processed before and the result files have been found.
disp('    Found all .mat files required.');
disp('        Loading the results...');

% Get 'contiPathLossesWithGpsInfo', 'contiOutFilesRelPathsUnderDataFolder'
% and 'contiOutFileIndicesReflection'.
load(ABS_PATH_TO_PATH_LOSSES_FILE);
% Get records of the TxInfo.txt files (among other contant parameters for
% the measurement campaign, e.g. F_S, TX_LAT, TX_LON, and TX_POWER_DBM):
% 	'TX_INFO_LOGS' and 'TX_INFO_LOGS_ABS_PAR_DIRS'.
load(ABS_PATH_TO_TX_INFO_LOGS_FILE);
% Get 'vegAreas', 'LAT_RANGE', 'LON_RANGE', 'VEG_AREA_IMG_RESOLUTION', and
% 'VEG_AREA_IMG_META'.
load(ABS_PATH_TO_VEG_AREAS_FILE);
% Get 'xTx', 'yTx', 'txUtmZone', 'treeLocations', 'pathLossUtmXYHs',
% 'pathLossUtmZones', 'treeUtmXYHs', and 'treeUtmZones'.
load(ABS_PATH_TO_UTM_INFO_FILE);
% Get 'numsOfTreesInFirstFresnel', 'freeSpacePathLosses',
% 'exceLossRefFreeSpace', 'excePathLossPerTree',
% 'shiftedFreeSpacePathLosses', 'excePathLossGroupWise', and
% 'groupWiseShiftedFreeSpacePathLosses'.
load(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE);
% Get 'modelTwoStepLinearLossWrtWFA' and all other site-specific models.
load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE);
% Get 'modelTwoStepLinearLossWrtWFA' and all other site-specific models.
load(ABS_PATH_TO_BEAM_POLYGONS_FILE);
% Get 'markLocs'.
load(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS);

disp('    Done!');

%% Create the Grid

disp(' ');
disp('    Generating extended RX location grid...');

% Create the grid in (lon, lat).
lonsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,2)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,2)'];
latsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,1)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,1)'];

lonVegArealimit = VEG_AREA_IMG_META.LON_RANGE;
latVegArealimit = VEG_AREA_IMG_META.LAT_RANGE;
lonsVegAreaPolygon = lonVegArealimit([1 1 2 2 1]);
latsVegAreaPolygon = latVegArealimit([1 2 2 1 1]);

[lonsEdgeIntersection, latsEdgeIntersection] = polyxpoly( ...
    lonsVegAreaPolygon, latsVegAreaPolygon, ...
    lonsEdgesDeterminedByTerrain, latsEdgesDeterminedByTerrain);

latLonRangePolyVertices = convexHull( ...
    [lonsEdgeIntersection latsEdgeIntersection; ...
    lonVegArealimit' latVegArealimit']);

if exist(pathToSaveGrid, 'file')
    histSimGridResults ...
        = load(pathToSaveGrid, 'simGrid');
else
    histSimGridResults.simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE = nan;
end

if histSimGridResults.simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE ...
        == simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE
    simGrid = histSimGridResults.simGrid;
else
    simGrid.latLonRangePolyshape = polyshape(latLonRangePolyVertices);
    
    % Convert to UTM (x, y).
    [xRangePolyVertices, yRangePolyVertices, utmZonesPoly] = deg2utm( ...
        latLonRangePolyVertices(:,2), latLonRangePolyVertices(:,1));
    simGrid.xYRangePolyshape = polyshape( ...
        [xRangePolyVertices yRangePolyVertices]);
    
    simGrid.utmZone = utmZonesPoly(1,:);
    
    % Construct the grid accordingly.
    simAreaMinX = min(simGrid.xYRangePolyshape.Vertices(:,1));
    simAreaMaxX = max(simGrid.xYRangePolyshape.Vertices(:,1));
    simAreaMinY = min(simGrid.xYRangePolyshape.Vertices(:,2));
    simAreaMaxY = max(simGrid.xYRangePolyshape.Vertices(:,2));
    
    simAreaWidthInM = simAreaMaxX-simAreaMinX;
    simAreaHeightInM = simAreaMaxY-simAreaMinY;
    
    gridResolution = max([simAreaWidthInM, simAreaHeightInM]) ...
        ./simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE;
    simGrid.resolutionInM = gridResolution;
    
    simAreaXLabels = constructAxisGrid( ...
        mean([simAreaMaxX, simAreaMinX]), ...
        floor((simAreaMaxX-simAreaMinX)./gridResolution), gridResolution);
    simAreaYLabels = constructAxisGrid( ...
        mean([simAreaMaxY, simAreaMinY]), ...
        floor((simAreaMaxY-simAreaMinY)./gridResolution), gridResolution);
    [simAreaXs, simAreaYs] = meshgrid(simAreaXLabels,simAreaYLabels);
    
    % Discard map grid points out of the area of interest.
    boolsGridPtsToKeep = inpolygon(simAreaXs(:), simAreaYs(:), ...
        simGrid.xYRangePolyshape.Vertices(:,1), ...
        simGrid.xYRangePolyshape.Vertices(:,2));
    
    simGrid.utmXYs = [simAreaXs(boolsGridPtsToKeep), ...
        simAreaYs(boolsGridPtsToKeep)];
    
    simGridXs = simGrid.utmXYs(:,1);
    simGridYs = simGrid.utmXYs(:,2);
    
    simGridNumOfPts = length(simGridXs);
    simGridZones = repmat(simGrid.utmZone, simGridNumOfPts, 1);
    [simGridLats, simGridLons] ...
        = utm2deg(simGridXs, simGridYs, simGridZones);
    simGrid.latLons = [simGridLats, simGridLons];
    
    % Use USGS 1/3 arc-second (~10m) resolution data for US terrain
    % elevation.
    latRange = [min(simGridLats), max(simGridLats)];
    lonRange = [min(simGridLons), max(simGridLons)];
    region = fetchregion(latRange, lonRange, 'display', true);
    nistElevData = region.readelevation(latRange, lonRange, ...
        'sampleFactor', 1, 'display', true);
    % Interperlate nistElevData to get lidarAlts.
    [nistElevDataLons, nistElevDataLats] = meshgrid( ...
        nistElevData.longs, nistElevData.lats);
    simGrid.eles = interp2( ...
        nistElevDataLons, nistElevDataLats, ...
        nistElevData.elev, ...
        simGridLons, simGridLats);
    
    % Fill USGS elevations in the spots with NaN elevation values.
    boolsNanEle = isnan(simGrid.eles);
    if any(boolsNanEle)
        simGrid.eles(boolsNanEle) = queryElevationPointsFromUsgs( ...
            simGridLats(boolsNanEle), simGridLons(boolsNanEle), 'matlab');
    end
    assert(all(~isnan(simGrid.eles)), ...
        'There are NaN elevation values for the grid points!');
    save(pathToSaveGrid, 'simGrid');
end

% Plot.
hFigAreaOfInterest = figure('visible', ~flagGenFigSilently); hold on;
hAreaOfInterest = plot( ...
    simGrid.xYRangePolyshape, ...
    'FaceColor', areaOfInterestColor);
hGridPts = plot(simGrid.utmXYs(:,1), ...
    simGrid.utmXYs(:,2), '.b', 'MarkerSize', 3, 'Color', darkBlue);
axis equal; view(2); grid on;
legend([hAreaOfInterest, hGridPts], ...
    'Area of interest', 'RX location grid points', ...
    'Location', 'SouthEast');
transparentizeCurLegends;


curDirToSave = fullfile(ABS_PATH_TO_SAVE_PLOTS, 'Overview_RxLocGrid.png');
saveas(hFigAreaOfInterest, curDirToSave);

disp('    Done!')

%% Export Grid as a Simulation RX Track

disp(' ');
disp('    Exporting grid to .csv...');

gridTrackFileLabel = 'simGrid';

% For convenience.
if ~exist('simGridXs', 'var')
    simGridXs = simGrid.utmXYs(:,1);
    simGridYs = simGrid.utmXYs(:,2);
    simGridLats = simGrid.latLons(:,1);
    simGridLons = simGrid.latLons(:,2);
    simGridNumOfPts = length(simGridXs);
    simGridZones = repmat(simGrid.utmZone, simGridNumOfPts, 1);
end

% Function to fetch elevation according to the vegetation data structure.
if ~exist('getUsgsEleInMFromUtmXY', 'var')
    disp('        Generating getUsgsEleInMFromUtmXY...');
    getUsgsEleInMFromUtmXY = scatteredInterpolant( ...
        VEG_AREA_IMG_META.XS(:), ...
        VEG_AREA_IMG_META.YS(:), ...
        VEG_AREA_IMG_META.ALTS(:));
end
TX_ALT_USGS = getUsgsEleInMFromUtmXY(xTx, yTx);

% RX grid points.
fullPathRxLocs = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_track_', gridTrackFileLabel, '.csv']);

curAltsUsgsRx = getUsgsEleInMFromUtmXY(simGridXs, simGridYs);
% Fill USGS elevations in the spots with NaN elevation values.
boolsNanEle = isnan(curAltsUsgsRx);
if any(boolsNanEle)
    curAltsUsgsRx(boolsNanEle) = queryElevationPointsFromUsgs( ...
        simGridLats(boolsNanEle), simGridLons(boolsNanEle), 'matlab');
end
assert(all(~isnan(curAltsUsgsRx)), ...
    'There are NaN USGS elevation values for the grid points!');

curRxGroundHeightWrtTx ...
    = curAltsUsgsRx-(TX_ALT_USGS+TX_HEIGHT_M);

if exist(fullPathRxLocs, 'file')
    disp('        Skipping track csv file generation for the grid!');
else
    curHeaderCell = {'utmX', 'utmY', 'utmZone', ...
        'lat', 'lon', 'altFromUsgs', 'rxHeightWrtTXInM'};
    
    curRxHeightWrtTxInM = (RX_HEIGHT_M+curAltsUsgsRx)...
        -(TX_ALT_USGS+TX_HEIGHT_M);
    
    curData = [num2cell([simGridXs, ...
        simGridYs]), ...
        cellstr(simGridZones), ...
        ...
        num2cell([simGridLats, simGridLons, ...
        curAltsUsgsRx, ...
        curRxHeightWrtTxInM])];
    writeToCsvWithHeader(fullPathRxLocs, curHeaderCell, ...
        curData, dataStrFormatter);
end

% Measurement results. For fields that we do no have data, we need to pad
% NaNs.
fullPathRxMeas = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_meas_', gridTrackFileLabel, '.csv']);
if exist(fullPathRxMeas, 'file')
    disp('        Skipping meas csv file generation for the grid!');
else
    curHeaderCell = {'locIdx', 'pathLossInDb', 'rxToTx3DDistInM', ...
        'txAzimuth (clockwise from positive y)', ...
        'txElevation ("+" for upward)', ...
        'rxAzimuth (clockwise from positive y)', ...
        'rxElevation ("+" for upward)'};
    
    curRxToTx3DDistInM = vecnorm([simGridXs - xTx, ...
        simGridYs - yTx, curRxHeightWrtTxInM], 2, 2);
    
    nanPaddings = nan(simGridNumOfPts, 1);
    onesWithNumOfCurMeas = ones(simGridNumOfPts, 1);
    
    curData = [(1:simGridNumOfPts)', nanPaddings, curRxToTx3DDistInM, ...
        nanPaddings, ...
        nanPaddings, ...
        nanPaddings, ...
        nanPaddings];
    writeToCsvWithHeader(fullPathRxMeas, curHeaderCell, ...
        curData, dataStrFormatter);
end

disp('    Done!');

%% Figures According to the Exported .csv Files

disp(' ');
disp('    Generate figures according to exported .csv files...');

% rxLoc_track_#.csv
rxLocExp = readtable(fullPathRxLocs);
rxUtmXYsExp = [rxLocExp.utmX, rxLocExp.utmY];
rxLonLatExp = [rxLocExp.lon, rxLocExp.lat];
rxHeightWrtTxExp = rxLocExp.rxHeightWrtTXInM;

% TX GPS location.
[latTx, lonTx] = utm2deg(xTx, yTx, txUtmZone);

% Overview figure on a map.
curFigTitle = {'Simulation Grid Overview'; ...
    'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewLonLatHByCsv.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;
hTx = plot(lonTx, latTx, 'gx');
hRx = plot(rxLonLatExp(:,1), rxLonLatExp(:,2), ...
    'r.', 'MarkerSize', 5);
hLidar = plot(lonsVegAreaPolygon, latsVegAreaPolygon, ...
    '-w', 'LineWidth', 3);
plot_google_map('MapType', 'satellite');
xlabel('Longtitude'); ylabel('Latitude');
legend([hTx, hRx, hLidar], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');
transparentizeCurLegends;

title(curFigTitle)
saveas(curFig, curFigPath);

% LiDAR data.
downSampleRate = 30;
fctDownSample = @(x) x(1:downSampleRate:end, 1:downSampleRate:end);
vegXsLessExp = fctDownSample(VEG_AREA_IMG_META.XS);
vegYsLessExp = fctDownSample(VEG_AREA_IMG_META.YS);
vegZsWrtTxLessExp = fctDownSample( ...
    VEG_AREA_IMG_META.ZS-TX_ALT_USGS-TX_HEIGHT_M);

[xsVegAreaPolygon, ysVegAreaPolygon] ...
    = deg2utm(latsVegAreaPolygon, lonsVegAreaPolygon);

% Overview figure in UTM.
curFigTitle = {'Simulation Grid Overview in 3D'; ...
    'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewUtmXYHByCsv.png');

curFig = figure('visible', ~flagGenFigSilently); hold on;

hLidar = plot3k([vegXsLessExp(:), vegYsLessExp(:), ...
    vegZsWrtTxLessExp(:)], 'Marker', {'.', 3}, 'ColorBar', false);

plot3([xTx xTx],[yTx yTx],[-TX_HEIGHT_M 0], 'g-');
hTx = plot3(xTx, yTx, 0, 'gx', 'LineWidth', 3, 'MarkerSize', 8);

plot3([rxUtmXYsExp(:,1) ...
    rxUtmXYsExp(:,1)]', ...
    [rxUtmXYsExp(:,2) ...
    rxUtmXYsExp(:,2)]', ...
    [rxHeightWrtTxExp curRxGroundHeightWrtTx]', ...
    'r-');
hRx = plot3(rxUtmXYsExp(:,1), rxUtmXYsExp(:,2), rxHeightWrtTxExp, ...
    'r.', 'MarkerSize', 5);

hLidarArea = plot(xsVegAreaPolygon, ysVegAreaPolygon, ...
    '-k', 'LineWidth', 3);

grid on; axis tight; axis equal; view(3);
xlabel('utmX'); ylabel('utmY'); ylabel('Height');
legend([hTx, hRx, hLidarArea], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');

title(curFigTitle)
saveas(curFig, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Generate Figures for Orignal Measurements
FLAG_GEN_FIGS_SILENTLY = true;

numOfTracks = length(contiPathLossesWithGpsInfo);
boolsToKeepMeas = cell(numOfTracks,1);
for idxTrack = 1:numOfTracks
    curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
    boolsToKeepMeas{idxTrack} = true(length(curLats),1);
end

curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simVsMeas'); %#ok<*NASGU>
genEvalPerfFigsForMeas;

%% Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary.

numOfTracks = length(contiPathLossesWithGpsInfo);
boolsToKeepMeas = cell(numOfTracks,1);
for idxTrack = 1:numOfTracks
    curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
    curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
    boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
        fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
        fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
end

curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, 'simVsMeasLess');
genEvalPerfFigsForMeas;

%% Further Clean Measurement Data
% We will find indices for discarding samples out of the first null range
% when necessary. Furthermore, we will discard track 6.

numOfTracks = length(contiPathLossesWithGpsInfo);
boolsToKeepMeas = cell(numOfTracks,1);
for idxTrack = 1:numOfTracks
    curLats = contiPathLossesWithGpsInfo{idxTrack}(:, 2);
    curLons = contiPathLossesWithGpsInfo{idxTrack}(:, 3);
    if idxTrack == 6
        boolsToKeepMeas{idxTrack} = false(length(curLons), 1);
    else
        boolsToKeepMeas{idxTrack} = inpolygon(curLons, curLats, ...
            fnbwLonLatPolyshapes{idxTrack}.Vertices(:,1), ...
            fnbwLonLatPolyshapes{idxTrack}.Vertices(:,2));
    end
end

curAbsPathToSavePlots = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simVsMeasLessNoTrackSix');
genEvalPerfFigsForMeas;

%% Refit Results to Cleaned Measurements

tx3D = [xTx, yTx, ...
    queryElevationPointsFromUsgs(latTx, lonTx, 'matlab')+TX_HEIGHT_M];
srcGpsPt3D = [latTx, lonTx, tx3D(3)];

% Evaluate the foliage area and distance in woodland for the measured
% locations.
cleanedMeasPredResults.contiPathLossesWithGpsInfo ...
    = curContiPathLossesExtraInfo;
allContiPathLossesWithGpsInfoCleaned = allContiPathLossesWithGpsInfo;

if exist(pathToSavePredictionsForGrid, 'file')
    disp('    Loading history results...');
    load(pathToSavePredictionsForGrid);
else
    [numOfMeasPts, ~] = size(allContiPathLossesWithGpsInfoCleaned);
    [measEles, measNumsOfFoliagePixelsInFirstFresnel] ...
        = deal(nan(numOfMeasPts, 1));
    measUtmXYs = nan(numOfMeasPts, 2);
    
    disp(' ');
    disp('            Foliage area computation for the measurements...');
    parfor idxMeasPt = 1:numOfMeasPts
        curMeasLat = allContiPathLossesWithGpsInfoCleaned(idxMeasPt,2);
        curMeasLon = allContiPathLossesWithGpsInfoCleaned(idxMeasPt,3);
        [curMeasX, curMeasY, ~] = deg2utm(curMeasLat, curMeasLon);
        curMeasEle = getUsgsEleInMFromUtmXY(curMeasX, curMeasY);
        dstGpsPt3D = ...
            [curMeasLat, curMeasLon, curMeasEle+RX_HEIGHT_M];
        
        measUtmXYs(idxMeasPt, :) = [curMeasX, curMeasY];
        measEles(idxMeasPt) = curMeasEle;
        [measNumsOfFoliagePixelsInFirstFresnel(idxMeasPt), ~, ~]...
            = countNumOfFoliagePixelsInFirstFresnelZone(...
            srcGpsPt3D, dstGpsPt3D, ...
            vegAreas, VEG_AREA_IMG_META, F_C_IN_GHZ);
        
        disp(['                Progress: ', ...
            num2str(idxMeasPt./numOfMeasPts.*100, '%.2f'), ...
            '% (pt #', num2str(idxMeasPt), ...
            '/', num2str(numOfMeasPts), ')']);
    end
    cleanedMeasPredResults.utmXYs = measUtmXYs;
    cleanedMeasPredResults.eles = measEles;
    cleanedMeasPredResults.foliageAreasInFirstFresnel ...
        = measNumsOfFoliagePixelsInFirstFresnel ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(1) ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(2);
    disp('                Done!');
    
    % FSPL for the measured locations.
    disp(' ');
    disp('            FSPL computation for the measurements...');
    [cleanedMeasPredResults.fsplInDb, ...
        cleanedMeasPredResults.distsToTxInM3d] ...
        = computeFreeSpacePathLosses(tx3D, ...
        [cleanedMeasPredResults.utmXYs, ...
        cleanedMeasPredResults.eles+RX_HEIGHT_M], F_C_IN_GHZ);
    disp('                Done!');
    
    disp(' ');
    disp('            Refitting site-specific model C...');
    % For two-step linear model for foliage area.
    modelTwoStepLinearLossWrtFA ...
        = simGridPredResults.modelTwoStepLinearLossWrtFA;
    fctToFit = @(paraToFit, input) ...
        modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        input, paraToFit(1), paraToFit(2), paraToFit(3), paraToFit(4));
    startingPtTwoStepLinearWrtFA = [1 0.1 18 30];
    fittedRes = nlinfit( ...
        cleanedMeasPredResults.foliageAreasInFirstFresnel, ...
        allContiPathLossesWithGpsInfoCleaned(:, 1), ...
        fctToFit, startingPtTwoStepLinearWrtFA);
    modelTwoStepLinearLossWrtFA.constPerUoFACloseFitted = fittedRes(1);
    modelTwoStepLinearLossWrtFA.constPerUoFAFarFitted = fittedRes(2);
    modelTwoStepLinearLossWrtFA.boundaryFitted = fittedRes(3);
    modelTwoStepLinearLossWrtFA.constShiftFitted = fittedRes(4);
    
    % Store the results.
    cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        = modelTwoStepLinearLossWrtFA;
    disp('                Done!');
    
    % Compute distance in woodland.
    disp(' ');
    disp('            Woodland distances for the measurements...');
    estiDistsNotInWoodland = nan(numOfMeasPts, 1);
    for idxMeasPt = 1:numOfMeasPts
        curGridPtX = cleanedMeasPredResults.utmXYs(idxMeasPt, 1);
        curGridPtY = cleanedMeasPredResults.utmXYs(idxMeasPt, 2);
        curLineTxToRxXs = [curGridPtX, xTx];
        curLineTxToRxYs = [curGridPtY, yTx];
        [interXs, interYs] = polyxpoly( ...
            curLineTxToRxXs, curLineTxToRxYs, ...
            clearanceZoneBoundXs, clearanceZoneBoundYs);
        estiDistsNotInWoodland(idxMeasPt) ...
            = norm([interXs-xTx, interYs-yTx]);
    end
    cleanedMeasPredResults.estiDistsInWoodland ...
        = cleanedMeasPredResults.distsToTxInM3d-estiDistsNotInWoodland;
    boolsGrisPtsOutofWood = inpolygon( ...
        allContiPathLossesWithGpsInfoCleaned(:, 3), ...
        allContiPathLossesWithGpsInfoCleaned(:, 2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
    cleanedMeasPredResults.estiDistsInWoodland(boolsGrisPtsOutofWood) = 0;
    disp('                Done!');
    
    % For the ITU model, fit Am to our data.
    disp(' ');
    disp('            Refitting ITU...');
    modelItuObsByWoodland = simGridPredResults.modelItuObsByWoodland;
    fctToFit = @(amToFit, d) modelItuObsByWoodland.excessLossFormula( ...
        d, modelItuObsByWoodland.gammaRecommended, amToFit);
    modelItuObsByWoodland.AmFitted = nlinfit( ...
        cleanedMeasPredResults.estiDistsInWoodland, ...
        allContiPathLossesWithGpsInfoCleaned(:, 1), ...
        fctToFit, rand(1));
    
    % Store the results.
    cleanedMeasPredResults.modelItuObsByWoodland ...
        = modelItuObsByWoodland;
    disp('                Done!');
end

%% Predictions for Extended RX Location Grid
% We will consider site-specific model C and the ITU model.

disp(' ');

if exist(pathToSavePredictionsForGrid, 'file')
    disp('    Loading history results...');
    load(pathToSavePredictionsForGrid);
else
    disp('    Generating predictions for extended RX locations...');
    
    disp('        FSPL...');
    % Free space loss values for all the points in the extended RX location
    % grid.
    [simGridPredResults.fsplInDb, simGridPredResults.distsToTxInM3d] ...
        = computeFreeSpacePathLosses(tx3D, ...
        [simGrid.utmXYs, simGrid.eles+RX_HEIGHT_M], F_C_IN_GHZ);
    
    disp('        Site-specific model C...');
    % Site-specific model C.
    historyModelResult ...
        = load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, ...
        'modelTwoStepLinearLossWrtFA');
    simGridPredResults.modelTwoStepLinearLossWrtFA ...
        = historyModelResult.modelTwoStepLinearLossWrtFA;
    
    % Estimate foliage areas, considering the RX height over the ground.
    numOfGridPts = length(simGrid.eles);
    simGridNumsOfFoliagePixelsInFirstFresnel = nan(numOfGridPts, 1);
    disp('            Foliage area computation...');
    parfor idxGridPt = 1:numOfGridPts
        dstGpsPt3D = [simGrid.latLons(idxGridPt,:), ...
            simGrid.eles(idxGridPt)+RX_HEIGHT_M]; %#ok<PFBNS>
        [simGridNumsOfFoliagePixelsInFirstFresnel(idxGridPt), ~, ~]...
            = countNumOfFoliagePixelsInFirstFresnelZone(...
            srcGpsPt3D, dstGpsPt3D, ...
            vegAreas, VEG_AREA_IMG_META, F_C_IN_GHZ);
        disp(['                Progress: ', ...
            num2str(idxGridPt./numOfGridPts.*100, '%.2f'), ...
            '% (pt #', num2str(idxGridPt), ...
            '/', num2str(numOfGridPts), ')']);
    end
    disp('                Done!');
    simGridPredResults.foliageAreasInFirstFresnel ...
        = simGridNumsOfFoliagePixelsInFirstFresnel ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(1) ...
        .*VEG_AREA_IMG_META.GRID_SIZE_IN_METER(2);
    
    simGridPredResults.siteSpecificModelCPredictionsInDbOld ...
        = simGridPredResults.fsplInDb ...
        + simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        simGridPredResults.foliageAreasInFirstFresnel, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        simGridPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    disp('        ITU...');
    % ITU.
    historyModelResult = load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, ...
        'modelItuObsByWoodland');
    simGridPredResults.modelItuObsByWoodland ...
        = historyModelResult.modelItuObsByWoodland;
    
    % The clearance zone needed for the ITU model to compute the
    % in-woodland distance.
    firstVertex = [39.9914866126997, -105.274771171001];
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        = [ firstVertex; ...
        ...
        39.9913983555729, -105.274683363792; ...
        39.99124280167, -105.27456460806; ...
        39.9912124631283, -105.274460246949; ...
        39.9911694375684, -105.274395471159; ...
        39.9910425673101, -105.274183150317; ...
        39.9918227291569, -105.274511732652; ...
        39.9917942146102, -105.274643656646; ...
        39.9916127585283, -105.274649294408; ...
        39.9918832145105, -105.274199963594; ...
        39.9919402435825, -105.274356693825; ...
        39.9917047826908, -105.27391130951; ...
        39.9918097680052, -105.273976707698; ...
        39.9916887972767, -105.273839709727; ...
        39.9916093022227, -105.273700456614; ...
        39.9913785927558, -105.273739921031; ...
        39.9912403393027, -105.27389721502; ...
        39.99131983505, -105.274652677151; ...
        39.9917316722478, -105.273962967618; ...
        ...
        firstVertex];
    [clearanceZoneBoundXs, clearanceZoneBoundYs] = deg2utm( ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2));
    [~, ~, clearanceZoneBoundNewOrderIndices] ...
        = orderPolygonVertices( ...
        clearanceZoneBoundXs, clearanceZoneBoundYs);
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        = simGridPredResults.clearanceZoneLatLonBoundaryAroundTx ...
        (clearanceZoneBoundNewOrderIndices, :);
    clearanceZoneBoundXs = clearanceZoneBoundXs ...
        (clearanceZoneBoundNewOrderIndices, :);
    clearanceZoneBoundYs = clearanceZoneBoundYs ...
        (clearanceZoneBoundNewOrderIndices, :);
    
    % Compute distance in woodland.
    numOfGridPts = length(simGrid.eles);
    estiDistsNotInWoodland = nan(numOfGridPts, 1);
    for idxGridPt = 1:numOfGridPts
        curGridPtX = simGrid.utmXYs(idxGridPt, 1);
        curGridPtY = simGrid.utmXYs(idxGridPt, 2);
        curLineTxToRxXs = [curGridPtX, xTx];
        curLineTxToRxYs = [curGridPtY, yTx];
        [interXs, interYs] = polyxpoly( ...
            curLineTxToRxXs, curLineTxToRxYs, ...
            clearanceZoneBoundXs, clearanceZoneBoundYs);
        estiDistsNotInWoodland(idxGridPt) ...
            = norm([interXs-xTx, interYs-yTx]);
    end
    simGridPredResults.estiDistsInWoodland ...
        = simGridPredResults.distsToTxInM3d-estiDistsNotInWoodland;
    boolsGrisPtsOutofWood = inpolygon(simGridLons, simGridLats, ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
        simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1));
    simGridPredResults.estiDistsInWoodland(boolsGrisPtsOutofWood) = 0;
    simGridPredResults.ituPredictionsInDbOld = ...
        simGridPredResults.fsplInDb ...
        + simGridPredResults.modelItuObsByWoodland.excessLossFormula( ...
        simGridPredResults.estiDistsInWoodland, ...
        simGridPredResults.modelItuObsByWoodland.gammaRecommended, ...
        simGridPredResults.modelItuObsByWoodland.AmFitted);
    
    % RMSDs compared with the simulation results.
    %     rmsdTwoStepLinearLossWrtFA = sqrt(mean( ...
    %      (allPredictedPathLossesTwoStepLinearLossWrtFA ...
    %     - allMeasPathLosses).^2));
    
    simGridPredResults.siteSpecificModelCPredictionsInDbNew ...
        = simGridPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .excessLossFormula( ...
        simGridPredResults.foliageAreasInFirstFresnel, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFACloseFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constPerUoFAFarFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .boundaryFitted, ...
        cleanedMeasPredResults.modelTwoStepLinearLossWrtFA ...
        .constShiftFitted);
    
    simGridPredResults.ituPredictionsInDbNew = ...
        simGridPredResults.fsplInDb ...
        + cleanedMeasPredResults.modelItuObsByWoodland.excessLossFormula( ...
        simGridPredResults.estiDistsInWoodland, ...
        cleanedMeasPredResults.modelItuObsByWoodland.gammaRecommended, ...
        cleanedMeasPredResults.modelItuObsByWoodland.AmFitted);
    
    save(pathToSavePredictionsForGrid, ...
        'cleanedMeasPredResults', 'simGridPredResults');
end

% Overview for the clearance zone around the TX.
allPLValues = [simGridPredResults.fsplInDb; ...
    simGridPredResults.ituPredictionsInDbOld; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
plRange = [floor(min(allPLValues)./10) ceil(max(allPLValues)./10)].*10;

hFigOverviewForClearanceZone = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, simGridPredResults.fsplInDb], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'FSPL (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ = max(simGridPredResults.fsplInDb)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
hClearanceZone = fill3( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
    ones(length( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1) ...
    )).*higherLayerZ, 'w');
alpha(hClearanceZone, 0.5); axis tight;
view(2);
legend([hTx, hTrees(1), hClearanceZone(1)], ...
    'TX', 'Trees', 'Clear zone', ...
    'Location', 'southeast');
plot_google_map('MapType', 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForClearanceZone.png');
saveas(hFigOverviewForClearanceZone, curFigPath);

% Overview of the results from ITU.
hFigOverviewForItu = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbOld], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old ITU (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ = max(simGridPredResults.ituPredictionsInDbOld)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
hClearanceZone = fill3( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,2), ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1), ...
    ones(length( ...
    simGridPredResults.clearanceZoneLatLonBoundaryAroundTx(:,1) ...
    )).*higherLayerZ, 'w');
alpha(hClearanceZone, 0.5); axis tight;
view(2);
legend([hTx, hTrees(1), hClearanceZone(1)], ...
    'TX', 'Trees', 'Clear zone', ...
    'Location', 'southeast');
% plot_google_map('MapType', 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForItu.png');
saveas(hFigOverviewForItu, curFigPath);

% Overview of the results from site-specific model C.
hFigOverviewForSiteSpecificC = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old SS-C (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simGridPredResults.siteSpecificModelCPredictionsInDbOld)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSiteSpecificC, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSiteSpecificC.png');
saveas(hFigOverviewForSiteSpecificC, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Model Prediction Comparisons

disp(' ');
disp('    Comparisons with the simulation results for the big grid...');

% The simulation results for the extended RX location grid.
simResultsForGridTable = readtable(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
simPLsForGridOrig = simResultsForGridTable.simLoss_dB_;

[~, curSimResultsForGridFilename] ...
    = fileparts(ABS_FILEPATH_TO_SIM_RESULTS_FOR_GRID);
if strcmpi(curSimResultsForGridFilename, ...
        'var_grnd_grid_propagation_stats_20191026')
    simPLsForGrid = nan(5742, 1);
    simPLsForGridIndices = simResultsForGridTable.id;
    simPLsForGrid(simPLsForGridIndices) = simPLsForGridOrig;
else
    simPLsForGrid = simPLsForGridOrig;
end

% Fit simulation results to FSPL at 1 m reference point.
if length(simPLsForGrid) == 5742
    idxForCloseInRefGridPt = 4550;
    % Also note that, for now, the const values of ~263 shown in
    % simPLsForGrid are not valide.
    simPLsForGrid(simPLsForGrid==simPLsForGrid(1)) = nan;
end

[xCloseInRefGridPt, yCloseInRefGridPt] = deg2utm( ...
    simGridLats(idxForCloseInRefGridPt), ...
    simGridLons(idxForCloseInRefGridPt));
distTxToCloseInRefGridPt = norm([xTx, yTx] ...
    - [xCloseInRefGridPt, yCloseInRefGridPt]);
fsplCloseInRefGridPt = simGridPredResults.fsplInDb(idxForCloseInRefGridPt);
simPLsForGridCalibrated = simPLsForGrid ...
    + fsplCloseInRefGridPt - simPLsForGrid(idxForCloseInRefGridPt);

% Overview of the simulation results.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simPLsForGridCalibrated], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Sim Results (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForGrid.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of FSPL.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simGridPredResults.fsplInDb], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'FSPL (dB)'}, ...
    'ColorRange', plRange([2,1]));
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForFspl.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the simulation results full range.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap hot;
plot3k([simGridLons, simGridLats, ...
    simPLsForGridCalibrated], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Sim Results (dB)'}, ...
    'ColorRange', [ceil(max(simPLsForGridCalibrated)), ...
    floor(min(simPLsForGridCalibrated))]);
higherLayerZ ...
    = max(simPLsForGridCalibrated)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'overviewForSimPLsForGrid_FullRange.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference between the ITU predictions and the simulation
% results.
fspsVsSimZs = simGridPredResults.fsplInDb - simPLsForGridCalibrated;
ituVsSimZsOld = simGridPredResults.ituPredictionsInDbOld ...
    - simPLsForGridCalibrated;
sscVsSimZsOld = simGridPredResults.siteSpecificModelCPredictionsInDbOld ...
    - simPLsForGridCalibrated;
ituVsSimZsNew = simGridPredResults.ituPredictionsInDbNew ...
    - simPLsForGridCalibrated;
sscVsSimZsNew = simGridPredResults.siteSpecificModelCPredictionsInDbNew ...
    - simPLsForGridCalibrated;

curPLDiffs = [ituVsSimZsOld; sscVsSimZsOld; ituVsSimZsNew; sscVsSimZsNew];
curColorRange = [ceil(max(curPLDiffs)), floor(min(curPLDiffs))];

hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap jet;
curZs = ituVsSimZsOld;
plot3k([simGridLons, simGridLats, curZs], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old ITU - Sim (dB)'}, ...
    'ColorRange', curColorRange);
higherLayerZ ...
    = max(curZs)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');
title(['RMSE = ', num2str(sqrt(mean(curZs(~isnan(curZs)).^2))), ' dB']);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridOldItuVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference between the site-specific C predictions and
% the simulation results.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap jet;
curZs = sscVsSimZsOld;
plot3k([simGridLons, simGridLats, curZs], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'Old SS-C - Sim (dB)'}, ...
    'ColorRange', curColorRange);
higherLayerZ ...
    = max(curZs)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');
title(['RMSE = ', num2str(sqrt(mean(curZs(~isnan(curZs)).^2))), ' dB']);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridOldSiteSpecificCVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap jet;
curZs = ituVsSimZsNew;
plot3k([simGridLons, simGridLats, curZs], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'New ITU - Sim (dB)'}, ...
    'ColorRange', curColorRange);
higherLayerZ ...
    = max(curZs)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');
title(['RMSE = ', num2str(sqrt(mean(curZs(~isnan(curZs)).^2))), ' dB']);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewItuVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Overview of the difference between the site-specific C predictions and
% the simulation results.
hFigOverviewForSimPLsForGrid = figure('visible', ~flagGenFigSilently);
hold on; colormap jet;
curZs = sscVsSimZsNew;
plot3k([simGridLons, simGridLats, curZs], ...
    'Labels', {'', 'Longitude', 'Latitude', '', 'New SS-C - Sim (dB)'}, ...
    'ColorRange', curColorRange);
higherLayerZ ...
    = max(curZs)+1;
hTx = plot3(lonTx, latTx, higherLayerZ, '^g', 'LineWidth', 2);
hTrees = plot3(markLocs(:,2), markLocs(:,1), ...
    ones(length(markLocs(:,1))).*higherLayerZ, 'b*');
axis tight;
view(2);
legend([hTx, hTrees(1)], ...
    'TX', 'Trees', ...
    'Location', 'southeast');
% plotGoogleMapAfterPlot3k(hFigOverviewForSimPLsForGrid, 'satellite');
title(['RMSE = ', num2str(sqrt(mean(curZs(~isnan(curZs)).^2))), ' dB']);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'comparisonForGridNewSiteSpecificCVsSim.png');
saveas(hFigOverviewForSimPLsForGrid, curFigPath);

% Plot diff vs TX-to-RX distance.
hFigDiffVsTxToRxDist = figure('visible', ~flagGenFigSilently);
hold on; alphaToSet = 1;
hFSPL = scatter(simGridPredResults.distsToTxInM3d, fspsVsSimZs, '*', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
hITU = scatter(simGridPredResults.distsToTxInM3d, ituVsSimZsOld, '^', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
hSSC = scatter(simGridPredResults.distsToTxInM3d, sscVsSimZsOld, '.', ...
    'MarkerFaceAlpha', alphaToSet, 'MarkerEdgeAlpha', alphaToSet);
title('Difference between Model Predictions and Simulation Results');
legend([hFSPL, hITU, hSSC], 'FSPL', 'ITU', 'Site-Specific C');
grid on;

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'predictionSimDiffVsDistToTx.png');
saveas(hFigDiffVsTxToRxDist, curFigPath);

if flagGenFigSilently
    close all;
end

disp('    Done!');

%% Extra Plots

% We will use surf for the path loss results.
simConfigs.UTM_X_Y_BOUNDARY_OF_INTEREST ...
    = simGrid.xYRangePolyshape.Vertices;
simConfigs.utm2deg_speZone = @(x, y) utm2deg(x, y, ...
    repmat(simGrid.utmZone, length(x),1));
simConfigs.deg2utm_speZone = @(lon, lat) deg2utm(lon, lat);
simConfigs.CURRENT_SIMULATION_TAG = 'NistForestGrid';
simConfigs.NUM_OF_PIXELS_FOR_LONGER_SIDE ...
    = simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE;
flagVisible = ~flagGenFigSilently;
txLonLats = [lonTx, latTx];
flagZoomIn = true;

allPathlossValues = [simGridPredResults.fsplInDb; ...
    simPLsForGridCalibrated; simGridPredResults.ituPredictionsInDbOld; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld; ...
    simGridPredResults.ituPredictionsInDbNew; ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew];
simConfigs.ALLOWED_PATH_LOSS_RANGE_IN_DB ...
    = [floor(min(allPathlossValues)./10), ...
    ceil(max(allPathlossValues)./10)].*10;

% Overview of FSPL.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.fsplInDb];
colorbarTitle = 'FSPL (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSimPLsForFspl.png');
saveas(hCurPLMap, curFigPath);

% Overview of the simulation results.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simPLsForGridCalibrated];
colorbarTitle = 'Sim Results (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSimPLsForGrid.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from ITU.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbOld];
colorbarTitle = 'Old ITU (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForItu.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from site-specific model C.
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbOld];
colorbarTitle = 'Old SS-C (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSiteSpecificC.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from ITU (new).
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.ituPredictionsInDbNew];
colorbarTitle = 'New ITU (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForItuNew.png');
saveas(hCurPLMap, curFigPath);

% Overview of the results from site-specific model C (new)..
matRxLonLatWithPathLoss = [simGridLons, simGridLats, ...
    simGridPredResults.siteSpecificModelCPredictionsInDbNew];
colorbarTitle = 'New SS-C (dB)';

[hCurPLMap, hCurHandleTxs] ...
    = plotPathLossMap(matRxLonLatWithPathLoss, txLonLats, ...
    simConfigs, flagVisible, flagZoomIn);
legend(hCurHandleTxs, 'TX', 'Location', 'southeast');
hCb = findall(hCurPLMap, 'type', 'ColorBar');
title(hCb, colorbarTitle);

curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'surfOverviewForSiteSpecificCNew.png');
saveas(hCurPLMap, curFigPath);

% For site-specific C model on measurements.
hFigPlOverAf = figure('visible', ~flagGenFigSilently); hold on;
% All measurements.
hAllMeas = plot();

%% Save Workspace for Manual Inspection
save(fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'workspace.mat'));

% EOF