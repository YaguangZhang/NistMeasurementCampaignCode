%EVALPERFBASEDONSIMRESULTS Evaluation the performance of site-specific
%models according to the simulation results from Lab
%
% Yaguang Zhang, Purdue, 09/13/2019

clear; clc; close all;

%% Configurations

warning('on');

% Add libs to current path and set ABS_PATH_TO_NIST_SHARED_FOLDER according
% to the machine name.
cd(fileparts(mfilename('fullpath')));
addpath(fullfile(pwd));
cd('..'); setPath;

% We will need the functions latLon2PixIndices.m and pixIndices2LatLon.m
% for working with the vegArea image.
addpath(fullfile(pwd, '9_GenerateVegAreas'));

% Configure other paths accordingly.
ABS_PATH_TO_SAVE_PLOTS = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PerformanceEvaluationBasedOnSimulations');

% Reuse results from evalPathLossesForContiTracks.m and
% loadMeasCampaignInfo.m.
ABS_PATH_TO_PATH_LOSSES_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputationConti', ...
    'contiPathLossesWithGpsInfo.mat');
ABS_PATH_TO_TX_INFO_LOGS_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'PathLossComputation', 'txInfoLogs.mat');

% Reuse results from generateVegAreas.m.
ABS_PATH_TO_VEG_AREAS_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'AutoGeneratedVegAreas', 'vegAreasMeta.mat');

% Reuse results from estimateFoliageAttenuation.m.
ABS_PATH_TO_UTM_INFO_FILE = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, ...
    'PostProcessingResults', 'FoliageAttenuationEstimation', ...
    'utmInfoForPathLossesAndTrees.mat');

% Reuse results from estimateFoliageAttenuationWithManualTreeLocs.m.
ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageAttenuationEstimation_ManualTreeLocs', ...
    'foliageAttenAnalysisResults.mat');

% Reuse results from compareFoliageDepthBasedModels.m.
ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'FoliageDepthBasedModelsComparison', ...
    'foliageDepthBasedAttenAnalysisResults.mat');

% The lengths of path within woodland (for the ITU model) and site-specific
% foilage depths will be saved into a file.
pathToSaveModelInfo = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'foliageDepthBasedAttenAnalysisResults.mat');

% The predictions from selected models will be saved.
pathToSaveGridAndPredictedPathlossMaps ...
    = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simulationGridAndPredictedPathlossMaps.mat');

% The 3 segment for length of path within woodland for evaluating the
% performance for the ITU model. Each segment will be the min and max
% values in the form of [min, max), i.e. including min but excluding max.
segmentsForRmseDw = {[0,30], [30,220], [220, inf]};

% The 3 segment for the foliage depth for evaluating the performance of
% Weissberger's model. Each segment will be the min and max values in the
% form of [min, max), i.e. including min but excluding max.
segmentsForRmseDf = {[0,15], [15,75], [75, inf]};

% The updated tree locations.
ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS ...
    = fullfile(ABS_PATH_TO_NIST_SHARED_FOLDER, 'PostProcessingResults', ...
    'ManuallyLocateMoreTrees', 'treeLocs.mat');

% For creating a grid to cover a larger area than that covered by our
% measurements. We will need the (latitude, longitude) range polygon stored
% as a polyshape to determin which area to cover.
latLonEdgesDeterminedByTerrain = {[39.992772, -105.275100; ...
    39.990018, -105.278469]; ...
    [39.989118, -105.276475; ...
    39.991211, -105.272842]};

% Control the truncation of the data in the output .csv files.
dataStrFormatter = '%.12f';

% For plotting.
lightGray = ones(1,3).*0.7;

% We will use this number of pixels for the longer side (width/height) of
% the simulation area; the number of pixels for the other side will be
% proportional to its length.
simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE = 100;

% For plotting.
areaOfInterestColor = [0.9290 0.6940 0.1250];
lightBlue = [0.3010 0.7450 0.9330];
darkBlue = [0 0.4470 0.7410];

%% Before Processing the Data

curFileName = mfilename;
fileNameHintRuler = [' ', repmat('-', 1, length(curFileName)+2), ' '];
disp(fileNameHintRuler)
disp(['  ', curFileName, '  '])
disp(fileNameHintRuler)

% Create directories if necessary.
if exist(ABS_PATH_TO_SAVE_PLOTS, 'dir')~=7
    mkdir(ABS_PATH_TO_SAVE_PLOTS);
end

%% Get Info for Measurement Data Files and Calibration Polynomials

disp(' ')
disp('    Loading results from: ')
disp('      - contiPathLossesWithGpsInfo.mat')
disp('      - txInfoLogs.mat')
disp('      - vegAreasMeta.mat')
disp('      - utmInfoForPathLossesAndTrees.mat')
disp('      - treeLocs.mat (Extended)')

assert(exist(ABS_PATH_TO_PATH_LOSSES_FILE, 'file')==2, ...
    'Couldn''t find contiPathLossesWithGpsInfo.mat! Please run PostProcessing/3_PathLossComputation/evalPathLossesForContiTracks.m first.');
assert(exist(ABS_PATH_TO_TX_INFO_LOGS_FILE, 'file')==2, ...
    'Couldn''t find txInfoLogs.mat! Please run PostProcessing/3_PathLossComputation/loadMeasCampaignInfo.m first.');
assert(exist(ABS_PATH_TO_VEG_AREAS_FILE, 'file')==2, ...
    'Couldn''t find vegAreasMeta.mat! Please run PostProcessing/9_GenerateVegAreas/generateVegAreas.m first.');
assert(exist(ABS_PATH_TO_UTM_INFO_FILE, 'file')==2, ...
    'Couldn''t find utmInfoForPathLossesAndTrees.mat! Please run PostProcessing/4_FoliageAttenuationEstimation/estimateFoliageAttenuation.m first.');
assert(exist(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE, 'file')==2, ...
    'Couldn''t find foliageAttenAnalysisResults.mat! Please run PostProcessing/8_FoliageAttenuationEstimation_ManualTreeLocs/estimateFoliageAttenuationWithManualTreeLocs.m first.');
assert(exist(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE, 'file')==2, ...
    'Couldn''t find foliageDepthBasedAttenAnalysisResults.mat! Please run PostProcessing/10_CompareFoliageDepthBasedModels/compareFoliageDepthBasedModels.m first.');
assert(exist(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS, 'file')==2, ...
    'Couldn''t find treeLocs.mat! Please run NistMeasurementCampaignCode/15_PerfEvaluationBasedOnSim/manuallyLocateMoreTrees.m first.');


% The data have been processed before and the result files have been found.
disp('    Found all .mat files required.');
disp('        Loading the results...')
% Get 'contiPathLossesWithGpsInfo', 'contiOutFilesRelPathsUnderDataFolder'
% and 'contiOutFileIndicesReflection'.
load(ABS_PATH_TO_PATH_LOSSES_FILE);
% Get records of the TxInfo.txt files (among other contant parameters for
% the measurement campaign, e.g. F_S, TX_LAT, TX_LON, and TX_POWER_DBM):
% 	'TX_INFO_LOGS' and 'TX_INFO_LOGS_ABS_PAR_DIRS'.
load(ABS_PATH_TO_TX_INFO_LOGS_FILE);
% Get 'vegAreas', 'LAT_RANGE', 'LON_RANGE', 'VEG_AREA_IMG_RESOLUTION', and
% 'VEG_AREA_IMG_META'.
load(ABS_PATH_TO_VEG_AREAS_FILE);
% Get 'xTx', 'yTx', 'txUtmZone', 'treeLocations', 'pathLossUtmXYHs',
% 'pathLossUtmZones', 'treeUtmXYHs', and 'treeUtmZones'.
load(ABS_PATH_TO_UTM_INFO_FILE);
% Get 'numsOfTreesInFirstFresnel', 'freeSpacePathLosses',
% 'exceLossRefFreeSpace', 'excePathLossPerTree',
% 'shiftedFreeSpacePathLosses', 'excePathLossGroupWise', and
% 'groupWiseShiftedFreeSpacePathLosses'.
load(ABS_PATH_TO_TREE_NUM_BASED_ANALYSIS_FILE);
% Get 'modelTwoStepLinearLossWrtWFA' and all other site-specific models.
load(ABS_PATH_TO_SITE_SPECIFIC_MODELS_FILE);
% Get 'markLocs'.
load(ABS_PATH_TO_MANUALLY_LABELED_TREE_LOCS);

disp('    Done!')

%% Create the Grid

% Create the grid in (lon, lat).
lonsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,2)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,2)'];
latsEdgesDeterminedByTerrain = [latLonEdgesDeterminedByTerrain{1}(:,1)' ...
    nan latLonEdgesDeterminedByTerrain{2}(:,1)'];

lonVegArealimit = VEG_AREA_IMG_META.LON_RANGE;
latVegArealimit = VEG_AREA_IMG_META.LAT_RANGE;
lonsVegAreaPolygon = lonVegArealimit([1 1 2 2 1]);
latsVegAreaPolygon = latVegArealimit([1 2 2 1 1]);

[lonsEdgeIntersection, latsEdgeIntersection] = polyxpoly( ...
    lonsVegAreaPolygon, latsVegAreaPolygon, ...
    lonsEdgesDeterminedByTerrain, latsEdgesDeterminedByTerrain);

latLonRangePolyVertices = convexHull( ...
    [lonsEdgeIntersection latsEdgeIntersection; ...
    lonVegArealimit' latVegArealimit']);

simGrid.latLonRangePolyshape = polyshape(latLonRangePolyVertices);

% Convert to UTM (x, y).
[xRangePolyVertices, yRangePolyVertices, utmZonesPoly] = deg2utm( ...
    latLonRangePolyVertices(:,2), latLonRangePolyVertices(:,1));
simGrid.xYRangePolyshape = polyshape( ...
    [xRangePolyVertices yRangePolyVertices]);

simGrid.utmZone = utmZonesPoly(1,:);

% Construct the grid accordingly.
simAreaMinX = min(simGrid.xYRangePolyshape.Vertices(:,1));
simAreaMaxX = max(simGrid.xYRangePolyshape.Vertices(:,1));
simAreaMinY = min(simGrid.xYRangePolyshape.Vertices(:,2));
simAreaMaxY = max(simGrid.xYRangePolyshape.Vertices(:,2));

simAreaWidthInM = simAreaMaxX-simAreaMinX;
simAreaHeightInM = simAreaMaxY-simAreaMinY;

gridResolution = max([simAreaWidthInM, simAreaHeightInM]) ...
    ./simGrid.NUM_OF_PIXELS_FOR_LONGER_SIDE;
simGrid.resolutionInM = gridResolution;

simAreaXLabels = constructAxisGrid( ...
    mean([simAreaMaxX, simAreaMinX]), ...
    floor((simAreaMaxX-simAreaMinX)./gridResolution), gridResolution);
simAreaYLabels = constructAxisGrid( ...
    mean([simAreaMaxY, simAreaMinY]), ...
    floor((simAreaMaxY-simAreaMinY)./gridResolution), gridResolution);
[simAreaXs, simAreaYs] = meshgrid(simAreaXLabels,simAreaYLabels);

% Discard map grid points out of the area of interest.
boolsGridPtsToKeep = inpolygon(simAreaXs(:), simAreaYs(:), ...
    simGrid.xYRangePolyshape.Vertices(:,1), ...
    simGrid.xYRangePolyshape.Vertices(:,2));

simGrid.utmXYs = [simAreaXs(boolsGridPtsToKeep), ...
    simAreaYs(boolsGridPtsToKeep)];

curXsRx = simGrid.utmXYs(:,1);
curYsRx = simGrid.utmXYs(:,2);

curNumOfRxLocs = length(curXsRx);
curZonesRx = repmat(simGrid.utmZone, curNumOfRxLocs, 1);
[curLatsRx, curLonsRx] = utm2deg(curXsRx, curYsRx, curZonesRx);
simGrid.latLons = [curLatsRx, curLonsRx];

% Plot.
hFigAreaOfInterest = figure; hold on;
hAreaOfInterest = plot( ...
    simGrid.xYRangePolyshape, ...
    'FaceColor', areaOfInterestColor);
hGridPts = plot(simGrid.utmXYs(:,1), ...
    simGrid.utmXYs(:,2), '.b', 'MarkerSize', 3, 'Color', darkBlue);
axis equal; view(2); grid on;
legend([hAreaOfInterest, hGridPts], ...
    'Area of interest', 'RX location grid points', ...
    'Location', 'SouthEast');
transparentizeCurLegends;

curDirToSave = fullfile(ABS_PATH_TO_SAVE_PLOTS, 'Overview_RxLocGrid.png');
saveas(hFigAreaOfInterest, curDirToSave);

%% Export Grid as a Simulation RX Track

gridTrackFileLabel = 'simGrid';

% Function to fetch elevation according to the vegetation data structure.
getUsgsAltInM = scatteredInterpolant( ...
    VEG_AREA_IMG_META.XS(:), ...
    VEG_AREA_IMG_META.YS(:), ...
    VEG_AREA_IMG_META.ALTS(:));
TX_ALT_USGS = getUsgsAltInM(xTx, yTx);

% RX grid points.
fullPathRxLocs = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_track_', gridTrackFileLabel, '.csv']);
curHeaderCell = {'utmX', 'utmY', 'utmZone', ...
    'lat', 'lon', 'altFromUsgs', 'rxHeightWrtTXInM'};

curAltsUsgsRx = getUsgsAltInM(curXsRx, curYsRx);

curRxGroundHeightWrtTx ...
    = curAltsUsgsRx-(TX_ALT_USGS+TX_HEIGHT_M);
curRxHeightWrtTxInM = (RX_HEIGHT_M+curAltsUsgsRx)...
    -(TX_ALT_USGS+TX_HEIGHT_M);

curData = [num2cell([curXsRx, ...
    curYsRx]), ...
    cellstr(curZonesRx), ...
    ...
    num2cell([curLatsRx, curLonsRx, ...
    curAltsUsgsRx, ...
    curRxHeightWrtTxInM])];
writeToCsvWithHeader(fullPathRxLocs, curHeaderCell, ...
    curData, dataStrFormatter);

% Measurement results. For fields that we do no have data, we need to pad
% NaNs. 

fullPathRxMeas = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    ['rxLoc_meas_', gridTrackFileLabel, '.csv']);
curHeaderCell = {'locIdx', 'pathLossInDb', 'rxToTx3DDistInM', ...
    'txAzimuth (clockwise from positive y)', ...
    'txElevation ("+" for upward)', ...
    'rxAzimuth (clockwise from positive y)', ...
    'rxElevation ("+" for upward)'};

curRxToTx3DDistInM = vecnorm([curXsRx - xTx, ...
    curYsRx - yTx, curRxHeightWrtTxInM], 2, 2);

nanPaddings = nan(curNumOfRxLocs, 1);
onesWithNumOfCurMeas = ones(curNumOfRxLocs, 1);

curData = [(1:curNumOfRxLocs)', nanPaddings, curRxToTx3DDistInM, ...
    nanPaddings, ...
    nanPaddings, ...
    nanPaddings, ...
    nanPaddings];
writeToCsvWithHeader(fullPathRxMeas, curHeaderCell, ...
    curData, dataStrFormatter);

%% Figures According to the Exported .csv Files

% rxLoc_track_#.csv
rxLocExp = readtable(fullPathRxLocs);
rxUtmXYsExp = [rxLocExp.utmX, rxLocExp.utmY];
rxLonLatExp = [rxLocExp.lon, rxLocExp.lat];
rxHeightWrtTxExp = rxLocExp.rxHeightWrtTXInM;

% TX GPS location.
[latTx, lonTx] = utm2deg(xTx, yTx, txUtmZone);

% Overview figure on a map.
curFigTitle = {'Simulation Grid Overview'; ...
    'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewLonLatHByCsv.png');

curFig = figure; hold on;
hTx = plot(lonTx, latTx, 'gx');
hRx = plot(rxLonLatExp(:,1), rxLonLatExp(:,2), ...
        'r.', 'MarkerSize', 5);
hLidar = plot(lonsVegAreaPolygon, latsVegAreaPolygon, ...
    '-w', 'LineWidth', 3);
plot_google_map('MapType', 'satellite');
xlabel('Longtitude'); ylabel('Latitude');
legend([hTx, hRx, hLidar], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');
transparentizeCurLegends;

title(curFigTitle)
saveas(curFig, curFigPath);

% LiDAR data.
downSampleRate = 30;
fctDownSample = @(x) x(1:downSampleRate:end, 1:downSampleRate:end);
vegXsLessExp = fctDownSample(VEG_AREA_IMG_META.XS);
vegYsLessExp = fctDownSample(VEG_AREA_IMG_META.YS);
vegZsWrtTxLessExp = fctDownSample( ...
    VEG_AREA_IMG_META.ZS-TX_ALT_USGS-TX_HEIGHT_M);

[xsVegAreaPolygon, ysVegAreaPolygon] ...
    = deg2utm(latsVegAreaPolygon, lonsVegAreaPolygon);

% Overview figure in UTM.
curFigTitle = {'Simulation Grid Overview in 3D'; 'Based on Exported Files'};
curFigPath = fullfile(ABS_PATH_TO_SAVE_PLOTS, ...
    'simGridOverviewUtmXYHByCsv.png');
    
curFig = figure; hold on;

hLidar = plot3k([vegXsLessExp(:), vegYsLessExp(:), ...
    vegZsWrtTxLessExp(:)], 'Marker', {'.', 3}, 'ColorBar', false);

plot3([xTx xTx],[yTx yTx],[-TX_HEIGHT_M 0], 'g-');
hTx = plot3(xTx, yTx, 0, 'gx', 'LineWidth', 3, 'MarkerSize', 8);

plot3([rxUtmXYsExp(:,1) ...
        rxUtmXYsExp(:,1)]', ...
        [rxUtmXYsExp(:,2) ...
        rxUtmXYsExp(:,2)]', ...
        [rxHeightWrtTxExp curRxGroundHeightWrtTx]', ...
        'r-');
hRx = plot3(rxUtmXYsExp(:,1), rxUtmXYsExp(:,2), rxHeightWrtTxExp, ...
        'r.', 'MarkerSize', 5);
    
hLidarArea = plot(xsVegAreaPolygon, ysVegAreaPolygon, ...
    '-k', 'LineWidth', 3);

grid on; axis tight; axis equal; view(3);
xlabel('utmX'); ylabel('utmY'); ylabel('Height');
legend([hTx, hRx, hLidarArea], ...
    'TX', 'Simulation grid', 'LiDAR data area', 'Location', 'SouthEast');

title(curFigTitle)
saveas(curFig, curFigPath);

% EOF