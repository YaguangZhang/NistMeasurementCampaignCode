function [ curContiPathLossesWithGpsInfo, absPathOutFile ] ...
    = computePathLossesForContiOutFileDir( ...
    curOutFileDir, contiGpsFilesDirs, ...
    noiseEliminationFct)
%COMPUTEPATHLOSSFORCONTIOUTFILEDIR Load the Gnu Radio samples stored in the
%.out file specified by the input dir struct outFileDir, and compute the
%path loss for it.
%
% We will consider both the TX calibration and the antenna normalization.
%
% Inputs:
%   - curOutFileDir
%     A dir struct specifying which .out file will be processed. Note:
%     curOutFileDir should at least has the field name, which contains the
%     full absolute path for the .out file to be processed, or only the
%     file name; For the second case, another field folder is required for
%     the full abosolute path of the parent folder.
%   - contiGpsFilesDirs
%     A dir struct array specifying all the GPS log files corresponding to
%     curOutFileDir.
%   - Other inputs
%     Please refer to computePathLossForCurSignal.m for more detail.
%
% Yaguang Zhang, Purdue, 09/26/2017

%% Parameters
% We will try loading them from the base workspace because these parameters
% should stay the same for the whole measurement campaign.

% TX power (after the upconverter) in dBm.
try
    txPower = evalin('base', 'txPower');
catch
    error('TX power (after the upconverter) txPower not found in the base workspace.')
end

% Sample rate used for GnuRadio.
try
    Fs = evalin('base', 'Fs');
catch
    warning('GnuRadio sample frequency Fs not found in the base workspace.')
    warning('Will use the default value 2 * 10^6.')
    Fs = 2 * 10^6;
end

% - lsLinesPolysInv, rxGains
%   The polynormials, and their corresponding RX gains, for the reference
%   calibration lines; Generated by 2_0_Calibration/calibratRx.m.
try
    lsLinesPolysInv = evalin('base', 'lsLinesPolysInv');
    rxGains = evalin('base', 'rxGains');
catch
    error(['Calibration information not found in the base workspace! ', ...
        'Please refer to 1_Calibration/calibrateRx.m for more detail.'])
end

%% Load Data

% All the GPS samples for this track.
numGpsSamples = length(contiGpsFilesDirs);
[lats, lons, alts] = deal(nan(numGpsSamples,1));
gpsLogs = cell(numGpsSamples,1);
for idxGpsSample = 1:numGpsSamples
    % Loading the GPS file.
    gpsLog = parseGpsLog(contiGpsFilesDirs(idxGpsSample).name);
    [lat, lon, alt, ~] = parseNmeaStr(gpsLog.gpsLocation);
    
    % Store the results.
    lats(idxGpsSample) = lat;
    lons(idxGpsSample) = lon;
    alts(idxGpsSample) = alt;
    gpsLogs{idxGpsSample} = gpsLog;
end

% Compute b for the calibration line corresponding to the RX gain.
usrpGains = cellfun(@(gpsLog) str2double(gpsLog.rxChannelGain), gpsLogs);
powerShiftsForCalis = genCalibrationFct( lsLinesPolysInv, ...
    rxGains, usrpGains);

% Get the epoch time stamp for the .oug file.
[~, outFileName] = fileparts(curOutFileDir.name);
epochTimeOutFileStr = regexp(outFileName, '_(\d+)$', 'tokens');
epochTimeOutFileStr = epochTimeOutFileStr{1}{1};
% Generate the full path for the .out file.
if isfield(curOutFileDir, 'folder')
    absPathOutFile = fullfile(curOutFileDir.folder, [outFileName, '.out']);
else
    absPathOutFile = curOutFileDir.name;
end
numComplexSamps = countComplexBinary(absPathOutFile);

%% Compute the Path Loss
% We will segment the input signal for the whole track according to the GPS
% samples and compute the path loss for each segment.

disp(['curContiPathLossesWithGpsInfo: Segmenting the conti signal ...'])

% More specifically, for each GPS sample, the signal segment right after it
% but before the next GPS sample will be assigned to this GPS sample.
gpsTimes = cellfun(@(gpsLog) str2double(gpsLog.gpsTime), gpsLogs);

% Make sure the GPS log files are already ordered according to GPS time.
assert(issorted(gpsTimes), ...
    'The GPS log files should be sorted by GPS time!');
% Make sure the first GPS log file was generated at the same time as the
% .out file.
[~, firstGpsFileName] = fileparts(contiGpsFilesDirs(1).name);
epochFirstGpsFileStr = regexp(firstGpsFileName, ...
    '_(\d+)_GPS$', 'tokens');
epochFirstGpsFileStr = epochFirstGpsFileStr{1}{1};
assert(strcmp(epochTimeOutFileStr, epochFirstGpsFileStr), ...
    'The first GPS log file should have the same timestamp as that for the .out file!')

% Only compute the path loss if the GPS sample is indeed covered by the
% measurement signal.
numGpsSamplesCovered = numGpsSamples;

measurementTimeLength = numComplexSamps/Fs;
idxFirstGpsSamplesNotCovered = ...
    find(gpsTimes-gpsTimes(1)>measurementTimeLength, 1);
if(~isempty(idxFirstGpsSamplesNotCovered))
    warning(['Only the first ', num2str(idxFirstGpsSamplesNotCovered-1), ...
        '/', num2str(numGpsSamples), ' GPS samples are covered by the .out file!']);
    numGpsSamplesCovered = idxFirstGpsSamplesNotCovered-1;
end

curContiPathLossesWithGpsInfo = nan(numGpsSamplesCovered,4);
for idxGpsSample = 1:numGpsSamplesCovered
    disp('curContiPathLossesWithGpsInfo: ');
    disp(['    Computing path loss for segment ', num2str(idxGpsSample), '/', ...
        num2str(numGpsSamplesCovered), '...']);
    
    % Find the signal segment for this GPS sample.
    if idxGpsSample<numGpsSamplesCovered
        % The sample indices cooresponding to this and the next GPS
        % samples.
        sigSampIndicesByGps = floor(Fs.*( ...
            [gpsTimes(idxGpsSample); gpsTimes(idxGpsSample+1)] ...
            -gpsTimes(1)));
        % We need to increase the start index by 1.
        curSigSegIdxRange = [sigSampIndicesByGps(1)+1, ...
            sigSampIndicesByGps(2)];
    else
        % For the last GPS sample, all the remaining signal samples will be
        % assigned to it.
        sigSampIdxForCurGps = floor(Fs.*( ...
            gpsTimes(idxGpsSample) ...
            -gpsTimes(1)));
        % We need to increase the start index by 1.
        curSigSegIdxRange = [sigSampIdxForCurGps(1)+1, ...
            numComplexSamps];
    end
    
    % Compute the path loss for the singal segment. We only need to discard
    % a small account of the starting samples at the very begining to avoid
    % the possible warm-up stage of the USRP.
    FlagCutHead = (idxGpsSample==1);
    % function [ pathLossInDb ] ...
    %     = computePathLossForCurSignal(curSignal, txPower, ...
    %       rxGain, noiseEliminationFct, powerShiftsForCali, FlagCutHead)
    pathLossInDb = computePathLossForCurSignal( ...
        readComplexBinaryInRange(absPathOutFile, curSigSegIdxRange), ... 
        txPower, usrpGains(idxGpsSample), noiseEliminationFct, ...
        powerShiftsForCalis(idxGpsSample), FlagCutHead);
    
    % Store the result as a [path loss (dB), lat, lon, alt] array.
    curContiPathLossesWithGpsInfo(idxGpsSample, :) ...
        = [pathLossInDb, ...
        lats(idxGpsSample), lons(idxGpsSample), alts(idxGpsSample)];
end

end
% EOF