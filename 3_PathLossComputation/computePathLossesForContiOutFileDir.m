function [ curContiPathLossesWithGpsInfo, absPathOutFile, oriAlts, ...
    outFileSampleRanges ] ...
    = computePathLossesForContiOutFileDir( ...
    curOutFileDir, contiGpsFilesDirs, ...
    noiseEliminationFct, FLAG_USE_GOOGLE_FOR_ALT, GOOGLE_MAPS_API)
%COMPUTEPATHLOSSFORCONTIOUTFILEDIR Load the Gnu Radio samples stored in the
%.out file specified by the input dir struct outFileDir, and compute the
%path loss for it.
%
% We will consider both the TX calibration and the antenna normalization.
%
% Inputs:
%   - curOutFileDir
%     A dir struct specifying which .out file will be processed. Note:
%     curOutFileDir should at least has the field name, which contains the
%     full absolute path for the .out file to be processed, or only the
%     file name; For the second case, another field folder is required for
%     the full abosolute path of the parent folder.
%   - contiGpsFilesDirs
%     A dir struct array specifying all the GPS log files corresponding to
%     curOutFileDir.
%   - FLAG_USE_GOOGLE_FOR_ALT, GOOGLE_MAPS_API
%     Set the flag to be true to use altitude information from Google,
%     instead of that from the GPS samples (because they may be too noisy).
%     For this case, please also provide a valid Google Maps Elevation API
%     key.
%   - Other inputs
%     Please refer to computePathLossForCurSignal.m for more detail.
%
% Update 04/01/2018: If the GnuRadio gain is set to a value that is not
% calibratable (e.g. some recording segments for the NIST data set), the
% computed path loss will be set to nan.
%
% Update 04/25/2018: Possible to use Google service to get altitudes for RX
% locations.
%
% Update 05/07/2018: Now also keep track of sample indices for the signal
% recording segement of each path loss value.
%
% Yaguang Zhang, Purdue, 09/26/2017

%% Parameters
% We will try loading them from the base workspace because these parameters
% should stay the same for the whole measurement campaign.

% TX power (after the upconverter) in dBm.
try
    txPower = evalin('base', 'txPower');
catch
    error('TX power (after the upconverter) txPower not found in the base workspace.')
end

% Sample rate used for GnuRadio.
try
    Fs = evalin('base', 'Fs');
catch
    warning('GnuRadio sample frequency Fs not found in the base workspace.')
    warning('Will use the default value 2 * 10^6.')
    Fs = 2 * 10^6;
end

% - lsLinesPolysInv, rxGains
%   The polynormials, and their corresponding RX gains, for the reference
%   calibration lines; Generated by 2_0_Calibration/calibratRx.m.
try
    lsLinesPolysInv = evalin('base', 'lsLinesPolysInv');
    rxGains = evalin('base', 'rxGains');
catch
    error(['Calibration information not found in the base workspace! ', ...
        'Please refer to 1_Calibration/calibrateRx.m for more detail.'])
end

% By default, we will use the altitude gotten by the GPS sensor.
if ~exist('FLAG_USE_GOOGLE_FOR_ALT', 'var')
    FLAG_USE_GOOGLE_FOR_ALT = false;
end

%% Load Data

% All the GPS samples for this track.
numGpsSamples = length(contiGpsFilesDirs);
[lats, lons, alts] = deal(nan(numGpsSamples,1));
gpsLogs = cell(numGpsSamples,1);
for idxGpsSample = 1:numGpsSamples
    % Loading the GPS file.
    gpsLog = parseGpsLog(contiGpsFilesDirs(idxGpsSample).name);
    [lat, lon, alt, ~] = parseNmeaStr(gpsLog.gpsLocation);
    
    % Store the results.
    lats(idxGpsSample) = lat;
    lons(idxGpsSample) = lon;
    alts(idxGpsSample) = alt;
    gpsLogs{idxGpsSample} = gpsLog;
end

oriAlts = [];
% Overwrite alts using informaiton from Google if necessary.
if FLAG_USE_GOOGLE_FOR_ALT
    oriAlts = alts;
    alts = nan;
    while isnan(alts)
        try
            alts = getElevationsFromGoogle(lats, lons, GOOGLE_MAPS_API);
        catch e
            warning(['GPS sample #', ...
                num2str(idxGpsSample), '/', num2str(numGpsSamples), ...
                ': Unable to get elevation from Google!'])
            disp(['    Error: ', e.identifier, '; Message: ', e.message]);
            disp('We will try again after waiting a littel bit.');
            pause(0.5);
        end
    end
end

% Compute b for the calibration line corresponding to the RX gain.
usrpGains = cellfun(@(gpsLog) str2double(gpsLog.rxChannelGain), gpsLogs);
[powerShiftsForCalis, boolsValidCaliGain] ...
    = genCalibrationFct( lsLinesPolysInv, ...
    rxGains, usrpGains);

% Get the epoch time stamp for the .oug file.
[~, outFileName] = fileparts(curOutFileDir.name);
epochTimeOutFileStr = regexp(outFileName, '_(\d+)$', 'tokens');
epochTimeOutFileStr = epochTimeOutFileStr{1}{1};
% Generate the full path for the .out file.
if isfield(curOutFileDir, 'folder')
    absPathOutFile = fullfile(curOutFileDir.folder, [outFileName, '.out']);
else
    absPathOutFile = curOutFileDir.name;
end
numComplexSamps = countComplexBinary(absPathOutFile);

%% Compute the Path Loss
% We will segment the input signal for the whole track according to the GPS
% samples and compute the path loss for each segment.

disp(['curContiPathLossesWithGpsInfo: Segmenting the conti signal ...'])

% More specifically, for each GPS sample, the signal segment right after it
% but before the next GPS sample will be assigned to this GPS sample.
gpsTimes = cellfun(@(gpsLog) str2double(gpsLog.gpsTime), gpsLogs);

% Make sure the GPS log files are already ordered according to GPS time.
assert(issorted(gpsTimes), ...
    'The GPS log files should be sorted by GPS time!');
% Make sure the first GPS log file was generated at the same time as the
% .out file.
[~, firstGpsFileName] = fileparts(contiGpsFilesDirs(1).name);
epochFirstGpsFileStr = regexp(firstGpsFileName, ...
    '_(\d+)_GPS$', 'tokens');
epochFirstGpsFileStr = epochFirstGpsFileStr{1}{1};
assert(strcmp(epochTimeOutFileStr, epochFirstGpsFileStr), ...
    'The first GPS log file should have the same timestamp as that for the .out file!')

% Only compute the path loss if the GPS sample is indeed covered by the
% measurement signal.
numGpsSamplesCovered = numGpsSamples;

measurementTimeLength = numComplexSamps/Fs;
idxFirstGpsSamplesNotCovered = ...
    find(gpsTimes-gpsTimes(1)>measurementTimeLength, 1);
if(~isempty(idxFirstGpsSamplesNotCovered))
    warning(['Only the first ', num2str(idxFirstGpsSamplesNotCovered-1), ...
        '/', num2str(numGpsSamples), ' GPS samples are covered by the .out file!']);
    numGpsSamplesCovered = idxFirstGpsSamplesNotCovered-1;
end

curContiPathLossesWithGpsInfo = nan(numGpsSamplesCovered,4);
outFileSampleRanges = nan(numGpsSamplesCovered,2);
for idxGpsSample = 1:numGpsSamplesCovered
    disp('curContiPathLossesWithGpsInfo: ');
    disp(['    Computing path loss for segment ', num2str(idxGpsSample), '/', ...
        num2str(numGpsSamplesCovered), '...']);
    if boolsValidCaliGain(idxGpsSample)
        % Find the signal segment for this GPS sample.
        if idxGpsSample<numGpsSamplesCovered
            % The sample indices cooresponding to this and the next GPS
            % samples.
            sigSampIndicesByGps = floor(Fs.*( ...
                [gpsTimes(idxGpsSample); gpsTimes(idxGpsSample+1)] ...
                -gpsTimes(1)));
            % We need to increase the start index by 1.
            curSigSegIdxRange = [sigSampIndicesByGps(1)+1, ...
                sigSampIndicesByGps(2)];
        else
            % For the last GPS sample, all the remaining signal samples
            % will be assigned to it.
            sigSampIdxForCurGps = floor(Fs.*( ...
                gpsTimes(idxGpsSample) ...
                -gpsTimes(1)));
            % We need to increase the start index by 1.
            curSigSegIdxRange = [sigSampIdxForCurGps(1)+1, ...
                numComplexSamps];
        end
        
        % Compute the path loss for the singal segment. We only need to
        % discard a small account of the starting samples at the very
        % begining to avoid the possible warm-up stage of the USRP.
        FlagCutHead = (idxGpsSample==1);
        % function [ pathLossInDb ] ...
        %     = computePathLossForCurSignal(curSignal, txPower, ...
        %       rxGain, noiseEliminationFct, powerShiftsForCali, ...
        %        FlagCutHead)
        pathLossInDb = computePathLossForCurSignal( ...
            readComplexBinaryInRange(absPathOutFile, curSigSegIdxRange), ...
            txPower, usrpGains(idxGpsSample), noiseEliminationFct, ...
            powerShiftsForCalis(idxGpsSample), FlagCutHead);
        
        outFileSampleRanges(idxGpsSample, :) = curSigSegIdxRange;
        
        if isinf(pathLossInDb)
            warning('The resulting pathloss is +/- inf! Resetting it to nan...')
            pathLossInDb = nan;
        end
    else
        warning('The GnuRadio gain for this sample is not calibratable!')
        pathLossInDb = nan;
    end
    
    % Store the result as a [path loss (dB), lat, lon, alt] array.
    curContiPathLossesWithGpsInfo(idxGpsSample, :) ...
        = [pathLossInDb, ...
        lats(idxGpsSample), lons(idxGpsSample), alts(idxGpsSample)];
end

% Discard samples with invalid info.
boolsValidSamps = arrayfun(@(idx) ...
    all(~isnan(curContiPathLossesWithGpsInfo(idx, :))), ...
    1:numGpsSamplesCovered);
curContiPathLossesWithGpsInfo ...
    = curContiPathLossesWithGpsInfo(boolsValidSamps, :);
oriAlts = oriAlts(boolsValidSamps);
outFileSampleRanges = outFileSampleRanges(boolsValidSamps, :);

end
% EOF